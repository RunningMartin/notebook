# IO模型

## 同步与异步(行为)

同步与异步的关注点在消息通信机制。即调用者是否等待被调用者返回信息。例子：打电话向老板询问书籍

- 同步：调用者等待被调用者返回信息。
- 异步：调用发出后，直接返回，调用者不会立刻获得结果，被调用者通过状态、通知来通知调用者，或通过回调函数处理调用。

## 阻塞与非阻塞(状态)

阻塞与非阻塞关注程序在等待调用结果时的状态。

- 阻塞：在调用结果返回之前，线程被挂起，只有得到结果后，才能返回。
- 非阻塞：当不能立即获得结果前，该调用不会阻塞线程。

## Unix中IO模型

- 阻塞IO：调用者调用后，会等待被调用者的通知，然后获得数据(在内核的缓冲区中准备好数据，然后从内核缓冲区拷贝数据到进程中，通知进程读数据。)(等通知)

- 非阻塞IO：进程将一个套接字设置为非阻塞状态，由调用者定时询问被调用者是否完成操作(没有完成会返回一个错误，完成后，会执行内核数据拷贝到进程中。)(主动询问)

- IO复用：实际上也是阻塞IO，阻塞在select、epoll系统调用上，没有阻塞在io调用中，先由select、epoll先进行系统调用，当内核准备好后，再通知调用者调用读取。(但需要阻塞着检查是否可读。**对同一个描述符的IO操作也是有序的。**)

- 信号驱动：采用信号机制等待，有了更多的进步，不用监视描述符了，而且不用阻塞着等待数据到来，被动等待信号通知，由信号处理程序处理。但对同一个描述符的IO操作还是有序的。

- 异步IO：发送IO请求后，不用等了，也不再需要发送IO请求获取结果了。等到通知后，其实是系统帮你把数据读取好了的，**你等到的通知也不再是要求你去读写IO了，而是告诉你IO请求过程已经结束了**。你要做的就是可以处理数据了。且同一个描述符上可能同时存在很多请求。(对应上面那个买书例子中，就是送书到我家，我直接看书就行了，不需要再去跑一趟了)。

- IO复用和信号驱动只是在处理业务逻辑上是异步，但是IO层面还是同步。

- 共同的阻塞： 内核拷贝数据到进程空间的这段时间需要等待。

- POSIX对这两个术语的定义：

  - 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；
  - 异步I/O操作：不导致请求进程阻塞。

- 阻塞，非阻塞：**进程/线程要访问的数据未准备就绪，进程/线程是否需要等待；**

- 同步，异步：**访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。**

- 作者：银月游侠

  链接：https://www.zhihu.com/question/19732473/answer/88599695

  来源：知乎

  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

  这几个概念，上面不少答案已经写得很清楚了。这里我结合自己的理解，简单地聊一下**为什么这几个概念容易混淆**。如果有错误之处，恳请批评指正。

  我认为同步、异步、阻塞、非阻塞，是分3个层次的：

  1. CPU层次；
  2. 线程层次；
  3. 程序员感知层次。

  这几个概念之所以容易混淆，是因为没有分清楚是在哪个层次进行讨论。

  **CPU层次**
  在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。

  **线程层次**

  在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：

  1. 多线程（同步阻塞）；
  2. IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
  3. 直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。

  

  **程序员感知层次**
  在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的**方式**还是异步的**方式**来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。

  **总结**

  因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

## 参考书籍

- 《Unix网络编程》