# MySQL实战—学习笔记

## 执行流程

- 执行流程
  - MySQL分为两层：Server层和存储引擎层。
  - Server层：负责处理客户端的请求并与存储引擎层交互
    - 连接器：管理连接与权限验证，可以通过`show processlist`查看。连接分为两种，短连接(每次只需完就断开)和长连接(持续请求，使用建立的连接)，通常建议使用长连接，但长连接会占用大量内存(执行SQL时的临时内存由连接对象管理)，内存占用很大时，MySQL会异常重启(被系统强杀)，因此建议在执行占用内存大的操作后断开连接或执行`mysql_reset_connection`重新初始化连接资源(该操作不需要重连)。
    - 查询缓存：如果该语句之前执行过，MySQL会以`key=语句，value=结果`的形式缓存，若语句在缓存中直接返回结果，若不在则执行后续步骤，将结果缓存。MySQL8.0已经取消掉缓存，因为缓存失效十分频繁(更新，则缓存失效)。8.0之前的版本可以设置参数`query_cache_type=DEMAND`默认不查询缓存或显式指定查询缓存`SELECT SQL_CACHE * FROM T;`。
    - 分析器：进行词法和语法分析，判断语句是否有误。
    - 优化器：确定语句的执行方案。
    - 执行器：判断执行权限，根据执行方案执行。
  - 存储引擎层：负责数据的存取
- MySQL资料收集
  - 用好debug模式
  - 《高性能MySQL》

## 日志系统：一条SQL更新语句是如何执行的？

- 更新流程：更新流程在执行时会涉及两个日志模块：重做日志(redo log)和归档日志(binlog)。
- 重做日志：重做日志是InnoDB数据引擎特有的日志。其目的是为了避免每次更新都写入磁盘带来的高消耗。MySQL会现将更新操作记录在重做日志中，然后更新内存中的数据，完成更新操作(WAL)。当系统空闲时，再将内存中的数据写入磁盘，通过该方法，InnoDB保证了数据库发送异常重启，也不会丢失数据(crash-safe)。重做日志是一个循环列表，如果写满，则必须将数据写入磁盘，擦除掉这部分日志。重做日志记录的是物理日志，即在某个数据页上做了什么修改。可以设置参数`innodb_flush_log_at_trx_commit=1`，确保每次事务的重做日志持久化到磁盘。
- 归档日志：归档日志是Server层的日志，记录更新语句的原始逻辑。归档日志是追加写的，写到一定大小后，会切换到新的日志。可以设置参数`sync_log=1`，确保每次事务的归档日志持久化到磁盘。
- 更新语句流程
- 数据恢复流程：根据对应时间点的全量备份恢复到临时库，然后将该时间点后的归档日志进行重放。
- 日志两段提交：保证两份日志的逻辑一致。
  - 重做日志为prepare状态时，在写binlog时crash
    - 重启恢复：没有commit，也没有binlog，回滚
  - 写完binlog后，出现crash
    - 重启恢复：已经写入了binlog，则自动commit

## 事务隔离

事务用于保证一组数据库操作要么全部完成，要么全部失败。MySQL的事务由引擎层实现，InnoDB支持事务，而MyISAM不支持事务。

- 事务的ACID特性
  - 原子性(Atomicity)：事务中所有的操作要么全部成功，要么全部失败。
  - 一致性(Consistency)：事务执行前和执行后状态一致。
  - 隔离性(Isolation)：事务之间的操作是互不影响。
  - 持久性(Durability)：事务提交后，对数据的修改是永久。
- 隔离级别：隔离越好，效率越低，配置方式`transaction-isolation`，其实现为视图，具体数据以视图为准。
  - 读未提交：事务未提交前，其变更能被其他事务读取到。没有创建视图，直接返回最新数据。
  - 读提交：事务提交后，其变更才能被其他事务读取到。每个SQL语句启动时创建视图。
  - 可重复读：事务执行过程中看到的数据和事务执行前看到的数据一致。事务启动时创建视图。
  - 串行化：添加读写锁，后续事务必须等前一个事务完成才能执行。

- 事务隔离的具体实现：事务隔离是基于回滚日志的，要想恢复数据，必须依次回滚。当系统中没有比该日志更早的视图时，即可删除掉该日志。
- 长事务：长事务意味着系统中会存在很老的事务视图，由于这些事务随时都可能访问数据库中的数据，因此事务提交之前，必须保留回滚日志，会占用大量存储空间。
- 事务启动

