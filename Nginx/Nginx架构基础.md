# Nginx架构基础

## Nginx请求处理流程

![Nginx请求处理流程]()

Nginx的核心是非阻塞的事件驱动处理引擎，因此需要状态机来正确识别和处理事件。Nginx有三个状态机：

- 传输层状态机：处理TCP、UDP的四层状态机。
- HTTP状态机：处理HTTP协议的应用层状态机。
- MAIL状态机：处理邮件的状态机。

## 进程结构

![Nginx进程结构]()

Nginx为了保证高可靠性，采用多进程结构，这是因为多线程中，一个线程出问题，会导致整个进程挂掉。Nginx中的进程分为：

- 父进程(Master Process)：负责Work进程管理，如是否需要重载配置文件。
- 子进程(Chile Process)
  - Work进程：负责请求处理
  - 缓存相关：负责缓存管理
    - Cacha Manager
    - Cache loader

Nginx中进程间的通信采用共享内存。Nginx采用事件驱动后，希望每个work进程都占用一颗CPU，因此生产环境中，不仅仅需要将Work进程数配置为CPU核数，还需要将Work进程和CPU相绑定，这样能更好使用每个CPU核上的CPU缓存，减少缓存失效问题。

## 进程结构实例演示

进程之间的通信采用共享内存实现，通过`nginx -s reload`命令重新加载配置文件时，子进程将被优雅关闭并重新创建。`reload`命令等价于`HUP`信号量，`kill -SIGHUP 父进程号`。向子进程发送`SIGTERM`信号量后，子进程将关闭，但父进程将重启一个新的进程。通过该演示可以发现，Nginx的很多子命令只是向master进程发送信号量。

## 使用信号管理Nginx的父子进程

通常进程之间的通信只采用信号量。

![进程的信号量]()

- Master进程
  - 监控Worker进程，`CHLD`：子进程挂掉后，会向父进程发送`CHLD`信号量，因此Master进程可以通过该信号量监控子进程的状态。
  - 接收信号
    - TERM，INT：立刻停止Nginx进程，对应stop指令。
    - QUIT：优雅停止Nginx进程，对应quit指令。
    - HUP：重载配置文件，对应reload指令。
    - USR1：重新打开日志文件，做日志文件切割，对应reopen指令。
    - USR2：开始热部署(启动新的进程，老worker进程不在处理请求)
    - WINCH：优雅关闭老work进程
- Worker进程(通常不直接对Worker进程发送信号)
  - TERM，INT
  - QUIT
  - USR1
  - WINCH

## 重载配置文件流程

![reload流程]()

疑点：

- 为什么master进程要打开新的监听端口？因为在Linux中，子进程继承父进程所有已经打开的端口。
- 为什么要先启动新进程，再关闭旧进程呢？如果先关闭旧进程，再打开新进程，会导致Nginx会有一定的时间不提供服务，因此为了进行平滑切换，要先启动新进程，再关闭旧进程。

![reload不停机载入新配置]()

在reload时，可以设置timeout，如果超时，则强制关闭老worker进程。

## 热升级的完整流程

![热升级流程]()

注意：

- 新的Nginx文件编译时，日志文件目录、配置文件目录等配置应该和老Nginx相同，否则无法复用配置文件。
- 回滚：向老master进程发送HUP，向新的master发送QUIT，然后替换会老nginx文件。
- 父进程退出时，如果子进程还在运行，则子进程将变为孤儿进程。孤儿进程将被init收养，因此老master进程退出时，新master不会退出。

![热升级流程图]()

## 优雅关闭Worker进程

优雅的关闭，意味着nginx能识别出连接是否在处理请求，对WebSocket、TCP是无法识别，因此优雅的关闭主要针对HTTP请求。

![优雅关闭Worker]()

## 网络收发与Nginx事件间的对应关系

![网络传输]()

![TCP流与报文]()

![TCP协议与非阻塞接口]()



生产者和消费者的关系，以事件的角度来理解

## Nginx网络事件实例

当建立TCP连接后，操作系统会通知Nginx，手动一个读事件，这个读事件对应着建立一个新连接，Nginx会通过accept去建立一个新连接。

## Nginx的事件驱动模型

![Nginx事件循环]()

- Nginx调用`epoll_wait`等待事件到来，处于sleep状态。
- 操作系统将已经准备好的时间放入读缓存中，并通知`epool_wait`。
- Nginx从读缓存中获取事件，进入事件处理流程。
- 事件处理完后，将相应的新事件放在写缓存中，有操作系统进行处理。

疑问

- post请求的数据量很大时，会不会导致事件队列中获取的读事件一直在读数据，阻塞其他事件？不会，TCP协议将post的数据切割为MSS大小，所以每处理完一个连接的若干报文消耗事件很短。

## epoll的特点

![epoll]()

epoll是基于每次处理的活跃连接数量占比小，因此采用链表存储活跃连接，连接建立成功后，事件由红黑树存储，获取事件时，才需要去链表rdllink中获取，事件的添加、修改、删除在红黑树上处理。

## Nginx的请求切换

![请求切换]()

nginx在用户态自行切换任务，避免CPU频繁切换任务，浪费大量的时间。Nginx需要将worker进程设置的优先级更高，这样操作系统分配的时间片会更长。

线程切换过程中，需要更新线程栈、线程切换成本非常高，内核态和用户态的拷贝成本也很高。

## 同步与异步、阻塞与非阻塞

同步与异步：同步和异步是从业务逻辑角度出发。

- 同步：调用接口后，需要等待接口处理完数据并返回后，才能继续执行。
- 异步：调用接口后，不必等接口准备完成可以继续执行。数据准备好后，通过回调等方式获取。
- 阻塞：调用接口后，如果接口没有准备好数据，进程将被挂起，CPU权限交给其他进程，直到数据准备好后，进程才被唤醒。
- 非阻塞：调用接口后，如果接口没有准备好数据，进程能进行后续处理。
- 综上：同步异步是指如果无法获取数据，代码逻辑的状态。阻塞和非阻塞是指如果无法获取数据，当前进程的状态(CPU是否在该进程掌握下)。

阻塞与非阻塞：调用的操作系统或C库的API是否会导致进程进入sleep状态。因为当前条件不满足，操作系统将CPU交给其他进程。非阻塞不会出现时间片未用完时，操作系统主动切换进程。

![阻塞调用]()

![非阻塞调用]()

## Nginx模块

![Nginx模块的重点]()

可以通过查看编译后的文件`objs/ngx_modules.c`中的信息，判断模块是否编译进入nginx。`nginx_module`数组包含所有编译进入的模块。

通过查看源码`src/modules.c`，可以查看支持的指令`ngx_command_t`。

![nginx模块的定义方法]()

Nginx模块的分类

`nginx_module_t`中定义了每个模块必须具备的特性，子模块中将定义自己特定的特性。`type`定义模块的类型。

![模块分类]()

`**_core`将包含这个子模块的通用逻辑。`upstream`将负责上游代理的业务。

`src/core`：nginx的核心框架代码。类比`nginx_http.c`定义了模块的工作流程。`modules`是可有可无的模块。

## Nginx连接池

### 连接池

![nginx连接池]()

每个worker进程，都有一个独立的ngx_cycle_t结构，其中包含三个数组：

- connections：连接池，由参数`worker_connections`控制，默认512。如果面向代理时，一个客户端消耗两个connection。
- read_events：读事件
- write_events：写事件

connections对应的连接池中，每个连接所需要的读写时间都以相同的序号对应着读写事件数组。

一个connection消耗232字节，一个connection对应两个事件，一个事件96字节，因此一个连接需要消耗424字节内存。实际上一个连接大概需要花5K

![核心数据]()

### 内存池对性能的影响

`ngx_connection_s`中`ngx_pool_t`对应该连接使用的内存池，通过配置项`connection_pool_size`可以配置，默认256|512字节。内存池将提前分配好一批内存，使用小片内存时，避免了频繁内存分配申请，也减少了内存碎片。开发者不必关注内存的释放，开发者只需分清楚自己是从请求内存池还是连接内存池中分配的内存，比如请求结束后，连接池仍可以使用。`request_pool_size`每一个请求的连接池大小，默认为4K，因为需要保存大量的上下文信息(header、url等)。

![内存池]()

## Worker进程协同

Nginx中的通信方式主要有两种：信号量、共享内存。使用共享内存时，需要引入锁(自旋锁，请求者一直请求，直到成功)，因此必须快速使用锁。Slab内存管理器用于管理内存。

![常用共享内存]()

`Ngx_http_lua_api`是OpenResty的核心模块，OpenResty在模块中定义了一个sdk，`lua_shared_dict 名称 大小`，分配一块共享内存。`lua_shared_dict`采用红黑树保存kv，采用链表进程lru(超过限制时，淘汰最近最少使用)。

### 共享内存管理

Slab用于管理共享内存，它将共享内存切割为页面，然后按不同的大小划分为slot，采用最佳匹配分配数据，适合用于小对象分配。

![Slab内存管理]()

通过`ngx_slab_stat`模块能查看使用状态，`:80/slab_stat`。该模块有tengine提供。编译OpenResty时，采用`--add-module=路径`添加目录。

```nginx
location=/slab_stat{
    slab_stat;
}
```

## Nginx容器

### 哈希表

- 数组：`ngx_array_t`，由多块连续内存组成，每块连续内存中能存储多个元素。
- 链表：`ngx_list_t`
- 队列：`ngx_queue_t`
- 哈希表：`ngx_hash_t`
- 红黑树：`ngx_rbtree_t`
- 基数树

![hash表结构]()

哈希表中，`ngx_hash_t`由多个`ngx_hash_elt_t`组成，value指向实际的数据。哈希表一般为静态不变的内容服务。

![哈希表配置]()

- `Max size`：控制哈希表中bucket的最大个数，不是实际上bucket的个数。
- `Bucket size`：控制元素的对齐大小。主流的CPU有多级缓存，CPU从内存中取数据的大小为Cache line(64字节)。设置Bucket size 的目的是避免每个元素只有59字节时，由于元素是紧密存放的，因此访问第二个元素时需要访问主存两次。Nginx通过Bucket size进行自动对齐，尽量不要超过64字节，避免多次访问主存。
- 参考[CPU Cache](http://cenalulu.github.io/linux/all-about-cpu-cache/)

### 红黑树

![红黑树结构]()

红黑树是一个自平衡的查找二叉树，其左右子树的高度差不会太大，避免退化为链表。

红黑树的特点：

- 高度不会超过2log(n)
- 增删改查的复杂度为O(log(n))
- 遍历复杂度O(n)

![常用使用红黑树的模块]()

## 动态模块

动态模块能提高运维效率，但不是所有的模块都支持动态模块，可以通过`./configure --help`查看有`dynamic`结尾的。编译动态模块的步骤：

- 编译，会生成动态模块库(so结尾，静态库是将源码编译进入二进制文件，而动态库在运行时由二进制文件进行调用，只需要修改某个库时，只需要编译相关的库即可)。编译时可以指定动态模块的位置
- 配置文件中，通过`load_module 动态模块位置`加载。
- 配置文件中进行配置。
- 重新加载配置文件。
- 工具：`screen`+`mosh`

