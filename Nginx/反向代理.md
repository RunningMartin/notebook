# 反向代理

## 概念

- 负载均衡：用户访问时，由nginx决定请求具体处理节点。通过负载均衡可以解决可用性问题(容灾、扩容)。Nginx可以在XYZ轴上进行扩展

  - X轴：适用于服务是无状态的，即水平扩展。如Round-Robin或least-connected算法分发请求。水平扩展不能解决节点的数据量大的问题。
  - Y轴：从功能上进行拆分，让不同的节点复杂不同的API(微服务)。Nginx将不同的API代理到不同的上游服务器中。
  - Z轴：基于用户的信息，进行分发请求(IP地址)。

- 反向代理

  - 4层反向代理，作用于TCP、UDP，上下游的连接类型相同。
  - 7层反向代理，作用于应用层，上下游的连接可以不同。

  ![反向代理]()

- 缓存：nginx可以通过缓存来提供响应速度。

  - 时间缓存：将用户的响应进行缓存，下一次直接发送缓存。
  - 空间缓存：nginx通过预取部分资源，来提高响应速度。

## upstream模块

upstream模块负责与上游服务进行交互。

### 配置上游服务集群

- `upstream`：通过server指令配置上游服务集群。

```nginx
Syntax: upstream name { ... }
Default: —
Context: http
```

- `server`：配置上游的服务器，地址有域名、IP、unix socket，如果不配置端口，则默认为80。parameters有：
  - `backup`：指定当前server为备份，只有当非备份服务不可用时，才可转发请求到该服务。
  - `down`：标识服务以及下线。
  - Round-Robin的指令。

```nginx
Syntax: server address [parameters];
Default: —
Context: upstream
```

### 加权Round-Robin负载均衡算法

Round-Robin算法通过加权轮询的方式访问指定的上游服务集群，权重代表服务节点的处理能力。该算法集成在Upstream中。

![加权Round-Robin负载均衡算法]()

### 对上游服务是否使用keepalive长连接

`ngx_http_upstream_keepalive_module`通过复用连接，降低nginx与上游服务器建立、关闭连接的消耗，提升吞吐量的同时也降低了延迟(效果更明显)。默认编译进入nginx。为了更好的使用keepalive，需要对上游连接的头部添加两个选项：

- `proxy_http_version 1.1;`：重置http version，防止用户发送1.0的协议(不支持keepalive)。
- `proxy_set_header Connection "";`：重置Connection，防止用户设置的有问题。

相关指令：

- `keepalive`：nginx与该组server最多保持多少个空闲tcp连接。

```nginx
Syntax: keepalive connections;
Default: —
Context: upstream
```

- `keepalive_requests`：一条TCP连接上最多跑多少个请求。

```nginx
Syntax: keepalive_requests number;
Default: keepalive_requests 100;
Context: upstream
```

- `keepalive_timeout`：一个TCP连接的空闲时间。

```nginx
Syntax: keepalive_timeout timeout;
Default: keepalive_timeout 60s;
Context: upstream
```

### 指定上游服务域名解析

- `resolver`：指定上游域名解析的DNS服务。

```nginx
Syntax: resolver address ... [valid=time] [ipv6=on|off];
Default: —
Context: http, server, location
```

- `resolver_timeout`：解析的超时时间。

```nginx
Syntax: resolver_timeout time;
Default: resolver_timeout 30s;
Context: http, server, location
```

实例：

```nginx
upstream rrups {
	server 127.0.0.1:8011 weight=2 max_conns=2 max_fails=2 fail_timeout=5;
	server 127.0.0.1:8012;
	keepalive 32;
}

server {
	server_name rrups.taohui.tech;
	error_log myerror.log info;

	location /{
		proxy_pass http://rrups;
		proxy_http_version 1.1;
        	proxy_set_header Connection "";
	}
}
```

### ip_hash模块

`ngx_http_upstream_ip_hash_module`模块以客户端的IP地址（remote_addr）作为hash算法的关键字，映射到特定的上游服务器中，针对IPv4，采用前三个字节；针对IPv6采用完整的地址，也可以通过realip模块修改执行算法的IP地址。默认编译进入nginx。

- `ip_hash`

```nginx
Syntax: ip_hash;
Default: —
Context: upstream
```

### hash模块

`ngx_http_upstream_hash_module `模块可以指定关键字作为hash key，通过hash算法映射到特定的上游服务器中。关键字可以包含字符与变量，也可以采用`round-robin`算法中的参数。

- `hash key [consistent]`

```nginx
Syntax: hash key [consistent];
Default: —
Context: upstream
```

实例

```nginx
log_format  varups  '$upstream_addr $upstream_connect_time $upstream_header_time $upstream_response_time '
                        '$upstream_response_length $upstream_bytes_received '
                        '$upstream_status $upstream_http_server $upstream_cache_status';

upstream iphashups {
	#ip_hash; # 使用ip hash模块是，权重不生效。
	hash user_$arg_username;
	server 127.0.0.1:8011 weight=2 max_conns=2 max_fails=2 fail_timeout=5;
	server 127.0.0.1:8012 weight=1;
}

server {
	set_real_ip_from  116.62.160.193;
	real_ip_recursive on;
	real_ip_header X-Forwarded-For;
	server_name iphash.taohui.tech;
	error_log myerror.log info;
	access_log logs/upstream_access.log varups;

	location /{
		proxy_pass http://iphashups;# 反向代理
		proxy_http_version 1.1;
        proxy_set_header Connection "";
	}
}

```

### 一致性hash算法

一致性hash算法是为了避免扩容或缩容时，hash算法引发的大量路由改变，可能导致缓存大范围失效。该算法有`ngx_http_upstream_hash_module `提供。

![一致性hash]()

使用方法：

```nginx
Syntax: hash key [consistent];
Default: —
Context: upstream
```

一致性hash算法的原理是：

- 一致性hash算法中会构建一个`2^32`的hash环。
- 将节点按hash结果放在环上。
- 按顺时针将结果较由下一个节点处理，因此扩容或缩容只会影响就近节点，影响比较小。还可以通过虚拟节点，将虚拟节点与实际节点相匹配，将修改影响范围控制到最小。

### least_conn模块

`ngx_http_upstream_ least_conn _module`模块能将请求转发到并发连接数最少的上游服务器，如果出现多个服务器的连接数相同，采用round-robin算法。默认编译进入nginx。

- `least_conn`

```nginx
Syntax: least_conn;
Default: —
Context: upstream
```

### zone模块

`ngx_http_upstream_ zone _module`模块通过分配共享内存，用于存储upstream模块定义的负载均衡策略、每个上游服务的状态，因此对所有的worker进程生效。

- `zone`

```
Syntax: zone name [size];
Default: —
Context: upstream
```

### upstream模块之间的顺序

模块的顺序决定了功能是否能正常运行，`ngx_module_t`中初始化顺序为从下往上，执行顺序为？？？(需要测试，通过配置两个相覆盖的配置进行测试)。

![执行顺序]()

### upstream模块提供的变量(不含缓存)

![变量1]()

![变量2]()

## 反向代理模块

### HTTP反向代理流程

转发给上游的也是HTTP协议

![HTTP反向代理流程]()

- 边读包体边发送存在一个问题：当包体很大时，传输时间很长，这时已经建立的连接将耗时很长，因此最好先通过buffer读取包体，然后再建立连接，发送连接。
- 内网网速很快，因此通常将`proxy_buffering`打开，先接受完整的包体，再向客户端发送，避免长时间占用内存。

proxy_pass指令优先级高于content中其他的指令

### proxy模块

`ngx_http_proxy_module`模块对上游服务事业HTTP/HTTPS进行反向代理。默认编译进入nginx。

- `proxy_pass`：将请求转发到相应的URL进行处理。

```nginx
Syntax: proxy_pass URL;
Default: —
Context: location, if in location, limit_except
```

URL必须用http://或https://开头，然后是域名、IP、unix socket地址或upstream名称，最后是可选的URI。不使用URI时，直接将客户端请求的URL转发给上流，location使用正则表达式或@时，使用该方法。使用URI时，将location参数中匹配到的部分替换为该URI。URL中也可以包含参数，更复杂的URL替换可以在location模块中添加rewrite break语句。

```nginx
location /a {
		proxy_pass http://proxy.com;# 访问时/a/b/c转发的url为http://proxy.com/a/b/c
    	proxy_pass http://proxy.com/www;# 访问时/a/b/c转发的url为http://proxy.com/www/b/c
	}
```

### 修改请求行

- `proxy_method`

```nginx
Syntax: proxy_method method;
Default: —
Context: http, server, location
```

- `proxy_http_version`

```nginx
Syntax: proxy_http_version 1.0 | 1.1;
Default: proxy_http_version 1.0;
Context: http, server, location
```

### 修改请求头部

- `proxy_set_header`

```nginx
Syntax: proxy_set_header field value;
# 如果变量为空字符串，则整个header都不会向上游发送
Default: proxy_set_header Host $proxy_host;
		 proxy_set_header Connection close;
Context: http, server, location
```

- `proxy_pass_request_headers`：是否发送用户的请求header

```
Syntax: proxy_pass_request_headers on | off;
Default: proxy_pass_request_headers on;
Context: http, server, location
```

### 修改包体

- `proxy_pass_request_body`：是否发送用户请求的body。

```nginx
Syntax: proxy_pass_request_body on | off;
Default: proxy_pass_request_body on;
Context: http, server, location
```

- `proxy_set_body`：手动构造发往上游的内容。

```nginx
Syntax: proxy_set_body value;
Default: —
Context: http, server, location
```

### 包体接收

- `proxy_request_buffering`：决定对客户端请求的包体是先收再转发还是边收边转发。

```nginx
# on适用于客户端网速慢、上游服务并发处理能力低、高吞吐量场景
# 设置off时，上游服务更及时的响应用户请求、降低nginx读写磁盘的损耗(写文件)、一旦开始发送内容，`proxy_next_upstream`失效
Syntax: proxy_request_buffering on | off;
Default: proxy_request_buffering on;
Context: http, server, location
```

- `client_body_buffer_size`：设置存在包体时，接受包体所分配的内存，若接受头部时已经接收完全部包体，则不分配；若剩余长度小于size，则分配所需大小；否则分配size大小。size与`proxy_request_buffering`相配合，关闭缓存时，将及时转发给上游服务器；打开缓存时，当该段内存用完后，将内容写入临时文件。

```nginx
Syntax: client_body_buffer_size size;
Default: client_body_buffer_size 8k|16k;
Context: http, server, location
```

- `client_body_in_single_buffer`

```nginx
Syntax: client_body_in_single_buffer on | off;
Default: client_body_in_single_buffer off;
Context: http, server, location
```

- `client_max_body_size`：最大包体长度，当请求头部中的`Content-Length`超过该大小后，返回413错误。

```nginx
Syntax: client_max_body_size size;
Default: client_max_body_size 1m;
Context: http, server, location
```

- `client_body_temp_path`：指定body存放的临时文件路径，level指定子目录，hash向后数，一个目录下文件过多，目录检索速度很慢。

```nginx
Syntax: client_body_temp_path path [level1 [level2 [level3]]];
Default: client_body_temp_path client_body_temp;
Context: http, server, location
```

- `client_body_in_file_only`：包体是否一直存在文件中，clear是必须存在文件中，但是请求处理完毕后，可以删除。off，当包体小于size时，不会存文件。

```nginx
Syntax: client_body_in_file_only on | clean | off;
Default: client_body_in_file_only off;
Context: http, server, location
```

- `client_body_timeout`：两次包体读取的最大间隔时间，超时返回408错误。

```nginx
Syntax: client_body_timeout time;
Default: client_body_timeout 60s;
Context: http, server, location
```

### 和上游服务建立连接

- `proxy_connect_timeout`：控制TCP三次握手时间，因此nginx相客户端发送502响应。

```nginx
Syntax: proxy_connect_timeout time;
Default: proxy_connect_timeout 60s;
Context: http, server, location
```

- `proxy_next_upstream`：设置遇到相应错误码后，更换一台上游服务器。

```nginx
Syntax: proxy_next_upstream http_502 | ..;
Default: proxy_next_upstream error timeout;
Context: http, server, location
```

- `proxy_socket_keepalive`：打开tcp中的keepalive，通过探测包去检测对端是否存活，然后关闭无效连接，释放资源。

```nginx
Syntax: proxy_socket_keepalive on | off;
Default: proxy_socket_keepalive off;
Context: http, server, location
```

- `keepalive`：复用的连接数。

```nginx
Syntax: keepalive connections;
Default: —
Context: upstream
```

- `keepalive_requests`：一个tcp连接能在执行多少个请求。

```nginx
Syntax: keepalive_requests number;
Default: keepalive_requests 100;
Context: upstream
```

- `proxy_bind`：nginx上有多个IP地址时，主动使用某个IP地址；

```nginx
# 可以使用变量proxy_bind $remote_addr
# 如果IP地址不是本机的地址，需要使用transparent，非linux下，要保证worker进程有root权限，才能修改socket的local address。通过修改IP头中的Source IP Address。
Syntax: proxy_bind address [transparent] | off;
Default: —
Context: http, server, location
```

- `proxy_ignore_client_abort`：当客户端出现失败，nginx是否与上游服务断开连接。默认关闭，因为会给上游带来很大的压力。

```nginx
Syntax: proxy_ignore_client_abort on | off;
Default: proxy_ignore_client_abort off;
Context: http, server, location
```

- `proxy_send_timeout`：向上游发送http请求后的超时时间。

```nginx
Syntax: proxy_send_timeout time;
Default: proxy_send_timeout 60s;
Context: http, server, location
```

### 接受上游服务的响应

- `proxy_buffer_size`：限定了接受上游服务返回的header的最大值，如果header很大时，`error.log`中会出现`error.logupstream sent too big header `。

```nginx
Syntax: proxy_buffer_size size;
Default: proxy_buffer_size 4k|8k;
Context: http, server, location
```

- `proxy_buffers`：当这段内存能存入包体时，不会写入磁盘。

```nginx
Syntax: proxy_buffers number size;
Default: proxy_buffers 8 4k|8k;
Context: http, server, location
```

- `proxy_buffering`：控制是否接收完整的响应包体。

```nginx
# 上游发送的响应中有X-Accel-Buffering头部(nginx)，为yes则强制nginx先接受完body，再发送
Syntax: proxy_buffering on | off;
Default: proxy_buffering on;
Context: http, server, location
```

- `proxy_max_temp_file_size`：限制写入磁盘中的临时文件最大只。

```nginx
Syntax: proxy_max_temp_file_size size;
Default: proxy_max_temp_file_size 1024m;
Context: http, server, location
```

- `proxy_temp_file_write_size`：每次向磁盘写入的字节数

```nginx
Syntax: proxy_temp_file_write_size size;
Default: proxy_temp_file_write_size 8k|16k;
Context: http, server, location
```

- `proxy_temp_path`：设置临时文件的保存位置。

```nginx
Syntax: proxy_temp_path path [level1 [level2 [level3]]];
Default: proxy_temp_path proxy_temp;
Context: http, server, location
```

- `proxy_busy_buffers_size`：先向客户端转发一定字节。

```nginx
Syntax: proxy_busy_buffers_size size;
Default: proxy_busy_buffers_size 8k|16k;
Context: http, server, location
```

- `proxy_read_timeout`：两次读取操作(TCP)的间隔时间。

```nginx
Syntax: proxy_read_timeout time;
Default: proxy_read_timeout 60s;
Context: http, server, location
```

- `proxy_limit_rate`：限制读取上游的响应。

```nginx
Syntax: proxy_limit_rate rate;
# 为0 则无限制
Default: proxy_limit_rate 0;
Context: http, server, location
```

- `proxy_store_access`：设置临时文件转存后的文件的权限。

```nginx
Syntax: proxy_store_access users:permissions ...;
# user:rw group:rw all:rw
Default: proxy_store_access user:rw;
Context: http, server, location
```

- `proxy_store`：设置临时文件转存后的目录，默认root指定的

```nginx
Syntax: proxy_store on | off | string;
Default: proxy_store off;
Context: http, server, location
```

### 加工响应

- `proxy_ignore_headers`：静止某些header干扰nginx的运行。

```nginx
Syntax: proxy_ignore_headers field ...;
Default: —
Context: http, server, location
```

特殊功能的header：`X-Accel`是与nginx相关的，用于控制nginx的行为。

![特殊功能header]()

- `proxy_hide_header`：设置nginx不转发相关头部

```nginx
Syntax: proxy_hide_header field;
Default: —
Context: http, server, location
```

![默认不转发的头部]()

- `proxy_pass_header`：转发被`proxy_hide_header`禁止的头部字段。

```nginx
Syntax: proxy_pass_header field;
Default: —
Context: http, server, location
```

- `proxy_cookie_domain`：修改cookie中的域名

```nginx
Syntax: proxy_cookie_domain off;
proxy_cookie_domain domain replacement;
Default: proxy_cookie_domain off;
Context: http, server, location
```

- `proxy_cookie_path`：替换cookie中的url。

```nginx
Syntax: proxy_cookie_path off;
proxy_cookie_path path replacement;
Default: proxy_cookie_path off;
Context: http, server, location
```

- `proxy_redirect`：修改重定向相关的`Location`头部

```nginx
Syntax:
proxy_redirect default;
proxy_redirect off;
proxy_redirect redirect replacement;
Default: proxy_redirect default;
Context: http, server, location
```

- `add_header`：添加header。

### 应对上游返回的错误

- `proxy_next_upstream`：前提是未向客户端发送任何内容，

```nginx
Syntax: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 |
http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;
# error：与上游发生网络错误(建立连接、读取响应)
# timeout：超时
# invalid_header：header不合法
# non_idempotent：非幂等操作也进行重试(POST、LOCK、PATCH)
# http_响应码：处理响应码，选取新的upstream
# off：关闭
Default: proxy_next_upstream error timeout;
Context: http, server, location
```

- `proxy_next_upstream_timeout`：超时时间

```nginx
Syntax: proxy_next_upstream_timeout time;
Default: proxy_next_upstream_timeout 0;
Context: http, server, location
```

- `proxy_next_upstream_tries`：重试次数。

```nginx
Syntax: proxy_next_upstream_tries number;
Default: proxy_next_upstream_tries 0;
Context: http, server, location
```

- `proxy_intercept_errors`：当上游响应的响应码大于等于300时，将响应返回客户端还是交给error_page指令处理。

```nginx
Syntax: proxy_intercept_errors on | off;
Default: proxy_intercept_errors off;
Context: http, server, location
```

实例

```nginx
error_page 500 /test1.txt;
location /intercept {
    proxy_intercept_errors on;
    proxy_pass http://127.0.0.1:8013;
}
```

### HTTPS认证

nginx在使用过程中主要有两个角色：

- 中转者

  - 对上游使用证书

    - `proxy_ssl_certificate file`

    ```nginx
    Syntax: proxy_ssl_certificate file;
    Default: —
    Context: http, server, location
    ```

    - `proxy_ssl_certificate_key file`

    ```nginx
    Syntax: proxy_ssl_certificate_key file;
    Default: —
    Context: http, server, location
    ```

  - 验证上游的证书

    - `proxy_ssl_verify on | off `

    ```nginx
    Syntax: proxy_ssl_verify on | off;
    Default: proxy_ssl_verify off;
    Context: http, server, location
    ```

    - `proxy_ssl_trusted_certificate file `

    ```nginx
    Syntax: proxy_ssl_trusted_certificate file;
    Default: —
    Context: http, server, location
    ```

- 服务器

  - 设置对下游的证书

    - `ssl_certificate file`

    ```nginx
    Syntax: ssl_certificate file;
    Default: —
    Context: http, server
    ```

    - `ssl_certificate_key file`

    ```nginx
    Syntax: ssl_certificate_key file;
    Default: —
    Context: http, server
    ```

  - 验证下游的证书

    - `ssl_verify_client on | off | optional | optional_no_ca`

    ```nginx
    Syntax: ssl_verify_client on | off | optional | optional_no_ca;
    Default: ssl_verify_client off;
    Context: http, server
    ```

    - `ssl_client_certificate file`

    ```nginx
    Syntax: ssl_client_certificate file;
    Default: —
    Context: http, server
    ```

- `ssl`模块还提供很多变量

- 创建证书

  - 创建根证书

    ```nginx
    # 创建CA私钥
    openssl genrsa -out ca.key 2048
    # 创建CA公钥
    openssl req -new -x509 -days 3650 -key ca.key -out ca.crt
    ```

  - 签发证书

    ```nginx
    # 创建站点私钥
    openssl genrsa -out a.pem 1024
    openssl rsa -in a.pem -out a.key
    # 生成签发请求
    openssl req -new -key a.pem -out a.csr
    # 使用CA证书进行签发证书
    openssl x509 -req -sha256 -in a.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out a.crt
    # 验证签发证书是否正确
    openssl verify -CAfile ca.crt a.crt
    ```


