# 数据结构与算法学习笔记—查找

## 二分查找

从一堆数中查找某个数是否存在，有两种思路：

- 遍历所有的数，判断该数是否存在，时间复杂度为$O(n)$。

- 二分查找：将数按从小到大排序后，从中间点开始判断，如果与中间点的值相等，则直存在；如果目标值小于中间值，在左半部分查找，否则在右半部分查找，当区间大小为0时，则完成查找。由于每次都排除了一半的元素，因此其空间复杂度计算为
  $$
  N/{2^k}=1  \quad k为查找次数
  \\
  k=log_2{N}
  $$
  因此其时间复杂度为$logN$。

### 递归实现

```python
def binary_search_recursive(elements, target):
    return binary_search_recursive_internal(elements, 0, len(elements)-1, target)

def binary_search_recursive_internal(elements, low, high, target):
    if low>high:
        return -1

    middle = low + ((high - low) >> 1)
    if target == elements[middle]:
        return middle
    elif target<middle:
        return binary_search_recursive_internal(elements, low, middle-1, target)
    else:
        return binary_search_recursive_internal(elements ,middle+1, high, target)
```



### 非递归实现

非递归实现中有两点需要注意：

- 结束条件是`low<=high`，而不是`low<high`。
- 中间值`middle=low + ((high - low) >> 1)`，这样可以防止`high+low`溢出(Python不会，但类似C语言会出现溢出)。

```python
def binary_search_recursive(elements, target):
    low = 0
    high = len(elements) - 1
    while low <= high:
        # prevent low+high overflow
        middle = low + ((high - low) >> 1)
        if elements[middle] == target:
            return middle
        if target < elements[middle]:
            high = middle - 1
        else:
            low = middle + 1
    return -1
```

### 二分查找的缺陷

二分查找有两个缺陷：

- 依赖于顺序表，因此数据量不能太大，防止内存申请失败。
- 顺序表中存储的数据必须是有序的。如果频繁插入删除元素会导致排序耗时过多，因此只适用于数据变化不频繁的有序顺序表。

### 思考题

- 如何用编程实现“一个数的平方根”？精确到小数点后6位。
  - 计算一个数A的平方根和二分查找相同，如果$(A/2)^2<num$，则说明其平方根在$[A/2,A]$之间，否则其平方根在$[0,A/2]$之间，通过多次计算逐步逼近，直到其精度满足。

    ```python
    def binary_sqrt(num):
        low = 0.0
        high = num
        middle = low + (high - low) / 2.0
        while abs(middle * middle - num) > 0.0000001:
            if middle * middle > num:
                high = middle
            else:
                low = middle
            middle = low + (high - low) / 2.0
        return middle
    ```

  - 牛顿迭代法：采用数学方法计算
    $$
    求解x^2=num \quad 等价于求解f(x)=x^2-num \quad 与x轴的交点
    \\已知曲线在点A处可以近似等价于该点处的切线，
    在f(x)与x轴时的交点x_n附近左切线
    \\切线与x轴的交点逼近x_n
    $$
    ![逼近图]()
    $$
    x_n处的切线公式：y=f(x_n)+f'(x_n)(x-x_n)
    \\
    切线与x轴交点：
    0=(x_n)+f'(x_n)(x_{n+1}-x_n)
    \\ x_{n+1}=x_n-f(x_n)/f'(x_n)
    \\x_{n+1}=1/2*(x+num/2x_n)
    $$

    ```python
    def sort_newton(num):
        x = num * 1.0
        while abs(x * x - num) > 0.0000001:
            x = 0.5 * (x + num / x)
        return x
    ```


### 参考

- [如何通俗易懂地讲解牛顿迭代法求开方？数值分析？](<https://www.zhihu.com/question/20690553>)

## 跳表





## 散列表





## 哈希算法



