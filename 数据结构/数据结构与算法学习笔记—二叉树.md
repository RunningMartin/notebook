# 二叉树

## 基本定义

- 父节点：
- 子节点：
- 兄弟节点：拥有相同的父节点。
- 叶子节点：没有子节点的节点。
- 根节点：没有父节点的节点。
- 节点的高度：节点到叶子节点的最长路径(边数)。
- 节点的深度：节点到根节点的路径(边数)。
- 节点的层：节点的深度+1。
- 树的高度：跟节点的高度。

## 二叉树

二叉树中，每个节点的子节点最多只有2个：左子节点、右子节点。

![二叉树]()

满二叉树：除了最后一层，每层的每个节点都有两个子节点。

完全二叉树：除最后一层以外，每层的节点数达到最大，最后一层，节点从左到右排布。

### 二叉树的存储

#### 链式存储

采用指针来串联节点

#### 基于数组的顺序存储法

利用二叉树中，节点i的左子树为2\*i，右子树为`2*i+1`的特性可将其存储在数组中，完全二叉树采用顺序存储最节约空间。

### 二叉树的遍历

- 前序遍历：先访问自身，再访问左子树，再访问右子树
- 中序遍历：先访问左子树，再访问自身，再访问右子树
- 后序遍历：先访问右子树，再访问右子树，再访问自身

二叉树的遍历是天然的递归，其时间复杂度为$O(N)$。

- 层次遍历：图的广度优先遍历。根节点入队，然后队首元素出队，将其左右孩子入队，知道队列和二叉树为空。空间复杂度为$O(N)$。
- 给N个数，能构建出多少种形态的二叉树。结果为卡特兰数$f(n)=\frac{(2n)!}{n!*(n+1)!}$。https://blog.csdn.net/hanlb912/article/details/38920085
  - n=0或n=1时只有一种形态：$f(0)=f(1)=1$。
  - n=2时，固定一个根节点后，剩余一个节点放左右子树：$f(2)=f(0)*f(1)+f(1)*f(0)$
  - n=3时，固定一个根节点，$f(3)=f(2)*f(0)+f(1)*f(1)+f(0)*f(2)$。
  - $f(n)=f(n-1)*f(0)+f(n-2)*f(1)+......+f(1)*f(n-2)+f(0)*f(n-1)$。

## 二叉树的应用 二叉查找树

二叉查找树要求：左子节点小于父节点，右子节点大于父节点。

- 查找操作：如果比节点大，则访问右子节点；如果比节点小，则访问左子节点；如果查找到叶子节点还未匹配，则不存在。
- 插入操作：如果比节点值大且右子节点为空，则插入右子节点，否则进入右子树查找合适位置；如果比节点值小且左子节点为空，则插入左子节点，否则进入左子树查找合适位置。
- 删除操作：删除操作分三种   leetcode 450
  - 叶子节点：字节删除
  - 只有一个子节点：直接将子节点连接到父节点。
  - 有两个子节点：查找出右子树的最小节点来替换(查找出大于节点的最小节点，保证二叉查找树的顺序要求)。
- 查找最大节点：查右子树
- 查找最小节点：查左子树
- 有序序列：进行中序排序。

在支持重复数据的二叉树中，键相同的节点有两种解决方案：

- 每个节点存储多个值。
- 将等于视作为大于。

时间复杂度分析，二叉查找树的时间复杂度和其树的高度成正比$O(height)$，因此降低时间复杂度的核心为降低其树的高度：平衡二叉排序树，近似于$O(logN)$。

二叉树和散列表相比的优点：

- 二叉查找树可以在$O(N)$内通过中序排序获得有序序列，而散列表的数据是无序排列的。
- 散列表扩容、哈希冲突耗时，设计考虑比较复杂。
- 散列表为避免散列冲突，装载因子不能太大，因此存在空间浪费。

如何获得二叉树的高度：

- 深度遍历：递归法MAX(左子树高度，右子树高度)+1。结束条件为height=0，node=null   leeetcode  104.
- 层次遍历

平衡二叉树：要求二叉树中任意一个节点的左右子树高度相差不能大于1。平衡二叉树的目的是为了解决普通二叉树在频繁插入删除等动态更新后，出现时间复杂度退化问题。因此我们设计平衡二叉树只需要整棵树左右相差不大，让其树的高度相差和$logN$差不多即可，严格的平衡二叉树的维护成本高。

