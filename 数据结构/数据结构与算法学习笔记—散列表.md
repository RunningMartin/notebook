# 数据结构与算法学习笔记—散列表

## 基础

散列表是数组的一种扩展，它通过哈希函数(散列函数)将元素的标识符映射为

数组的下标，然后利用数组下标直接获取元素，其时间复杂度为$O(1)$。

散列表的难点有两个：

- 哈希函数的设计。
- 如何解决散列冲突(不同元素的hash值相同)。

## 哈希函数

一个好的哈希函数有如下三个基本要求：

- 哈希函数得出的哈希值是一个非负整数。
- 如果`key1=key2`，则`hash(key1)=hash(key2)`。
- 如果`key1！=key2`，则`hash(key1)！=hash(key2)`。

如果`key1!=key2`，但`hash(key1)=hash(key2)`，这种现象被称作为**散列冲突**。因为数组的存储空间有限，加剧了散列冲突的概率，所有无法找到一个完美的无冲突的散列函数。基于对成本的考虑，只能想办法去处理散列冲突。

## 散列冲突

### 开放寻址法

开放寻址法的核心思想是：出现散列冲突，重新探测一个空闲位置。
- 线性探测
- 二次探测
- 双重散列

#### 线性探测

线性探测的核心思想是：

- 插入元素：如果出现散列冲突，则从当前位置往后找空闲，插入元素。
- 查找元素：从散列函数得出的散列值开始，依次往后对比，如果相等，则找到元素；如果出现空闲位置，则表示元素不存在。
- 删除元素：不能直接删除元素，因为删除元素后会出现空闲位置，从而导致查找算法失效。删除只能标记为删除，当插入时，没有多余空闲位置，进行rehash操作，将元素重新排列。

线性探测存在一个缺陷：插入的元素越多，出现散列冲突的可能性越大，空闲位置越少，线性探测时间越长，最坏时间复杂度为$O(n)$。

#### 二次探测

线性探测每次的探测步长为`1`，其探测的下标为$(hash(key)+0)%n$，$(hash(key)+1)%n$，$(hash(key)+2)%n$等。二次探测每次的探测步长为$i^2$，其探测下标为$(hash(key)+0^2)%n$，$(hash(key)+1^2)%n$，$(hash(key)+2^2)%n$等。

#### 双重散列 

双重散列是采用一组哈希函数，如果第一个哈希函数得出的位置已经被使用，则使用第二个哈希函数，以此类推，直到找到空闲的存储位置位置。
三种探测方法都面临着当散列表中空闲位置越少，散列冲突的概率越大。为了确保散列表的性能，会通过保证散列表中有一定比例的空闲位置。散列表实际使用容量的比例为$使用数量 /dev 总容量$，该比例被称作为**装载因子**。当装载因子到达极限值时，则需要对散列表进行扩缩容，以确保性能。

### 链表法

链表法的核心思想：使用一维数组作为槽位，每个槽位指向一个链表，链表中存储散列值相同的元素。插入、查找、删除操作只作用于槽位所对应的链表。

![链表法]()

因此，插入删除操作的时间复杂度与链表长度`K`成正比，为$O(K)$。如果哈希函数设计的比较均匀，则$K \approx \frac{n}{m}$，`n`为元素个数，`m`为槽位数。
