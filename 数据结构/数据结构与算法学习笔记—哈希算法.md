# 数据结构与算法学习笔记—哈希算法

**哈希算法**：将任意长度的二进制值串映射为固定长度的二进制值串。这个固定长度的二进制值串就是哈希值。

**如何设计优秀的哈希算法？**：

- 单向哈希：不能通过哈希值反推出原始数据。
- 篡改无效：小幅度修改也会导致哈希值发生大变化。
- 散列冲突：哈希冲突概率低。
- 执行效率：运行效率高效。

常用的哈希算法有MD5(哈希值为128位Bit长度)和SHA算法。

## 安全加密

用于加密的哈希算法必须满足两条：单向(保密)和哈希冲突低。根据鸽巢原理(鸽子数大于鸽巢数时，一定会出现冲突)，哈希函数无法做到零冲突。MD5算法的哈希值是128位二进制串，因此最多表示$2^128$个数据，但是目标数据个数是无限的，因此一定会出现冲突。

加密算法存在越安全的算法但计算时间越长的情况，因此需要权衡破解难度和计算时间。

安全加密后，存在字典攻击的威胁：维护一个常用密码的字典表，通过将脱库后的哈希值与字典表中的哈希值相比较，可以猜出是否使用的是常用密码。针对这种情况，采用加盐的方法，将密码与盐一起计算哈希值，增加破解难度。还可以采用hash时间固定和慢算法(PBKDF2WithHmacSHA1算法)来降低hash计算速度，减少不同长度字符串计算hash所需时间不同而泄露字符串长度信息。

## 唯一标识

在图库中搜索图片不存在的场景下，可以通过计算图片二进制码串的哈希值来为每张图片建立唯一标识(针对超大文件，可以使用采样来获取原始数据)。建立唯一标识与图库路径的散列表，因此查找图片是否存在，可以先获取该图片的唯一标识，查询散列表，如果散列表中查询不到，则不存在；如果散列表中能查到，则将二者进行全量对比，判断是否存在哈希冲突。

## 数据校验

通过BT种子下载文件时，会从多个机器上并行下载一个文件。该文件被切割为很多文件块，等所有的文件块都下载完成后，再进行组装即可。下载过程中，有一个十分核心的问题：如何确保每个文件块都是正确的呢？

有一种解决方案是将每一块的哈希值存放在种子文件中，通过比较下载文件块的哈希值与种子文件中的哈希值对比，确保每个文件块都是正确的。

## 散列函数

散列函数最关注的是一组数据是否能均匀散列在各个槽中和运行的效率。

## 负载均衡

负载均衡可以通过轮询、随机、加权轮询等方法实现，但使用哈希算法的负载均衡可以实现将同一个会话中的所有请求路由到同一个服务器。

通过哈希算法计算客户端的IP或会话ID的哈希值，然后与服务器列表大小进行取模运算，最终获得目标服务器的编号。

## 数据分片

场景一：1T的用户搜索关键词日志文件，如何快速统计出每个关键词被搜索的次数？该问题的难点是：

- 超大文件不能放入内存处理。
- 单机处理耗时慢。

因此可以依次将每个关键字提取出来，然后计算哈希值，通过散列值与节点个数取模，将信息发送到相应节点，由节点统计出现次数，最后汇总即可。

场景二：如何快速判断图片是否存在图库中？该问题的难点在图库中的图片数量上亿，在单节点的内存中难以构建散列表，因此在存储图片之前可以先利用哈希函数求该图片的唯一标识，然后与节点格式取余，将图片存在相应节点；查询时也执行相同步骤。

## 分布式存储

面对海量数据的读取、写入时，可以通过数据分片中的思路，将数据分布在多个节点中。采用分布式存储时，不可避免的问题是：如何解决增加节点后，导致所有已经存储的数据需要rehash操作。因此缓存中的数据将全部失效，所有的数据请求将穿透缓存，直接去请求数据库，出现数据雪崩。针对这种情况可以采用一致性哈希算法来解决。

普通哈希算法的缺点是当出现rehash时，几乎所有的数据都要移动位置，因此核心问题是如何减少受影响的数据数量？。一致性哈希算法通过一个哈希环巧妙解决了该问题。哈希环上有$2^{32}$个槽位，通过哈希算法计算节点对应的槽位：$hash%2^{32}$。三个服务器A、B、C的位置如图：

![节点初始化位置]()

存入数据时，也通过哈希算法计算数据对应的槽位$hash%2^{32}$，因此数据的分为会如图：

![数据分布]()

存储数据的节点为顺时针最近的节点。

如果减少一个节点，则只会导致该节点所存储的数据存入下一个节点，不会影响其他节点的数据信息。

![节点减少]()

如果增加一个节点，则会分担插入点下一个节点的部分数据。

![节点增加]()

### hash环的偏斜

理想状态下，节点会均匀分布在hash环上，但实际上可能会导致大部分数据缓存到某一节点。

![hash环偏斜]()

针对这种情况，引入了虚拟节点的概念。虚拟节点是节点在环上的一个复制品，一个节点可以对应多个虚拟节点。虚拟节点越多，缓存均匀分布的概率越大。
