# 数据结构与算法学习笔记—基础算法

## 递归

例子：有n个台阶，每次可以下1个台阶或两个台阶，请问走n个台阶有多少种走法？

解法：这个问题求解可以分解为两个子问题：先下一个台阶或先下两个台阶，因此可以写出其递推公式：$f(n)=f(n-1)+f(n-2)$。该递推公式的终止条件为：$f(1)=1$，$f(2)=2$。根据上述3个公式，可以写出代码：

```python
def downstair(n):
    if n==1:
        return 1
    if n==2:
        return 2
    return downstair(n-1)+downstair(n-2)
```

这个例子的实现就是一个完整的递归代码实现。编写递归代码的关键是找到将大问题拆分为小问题的规律，根据规律编写递推公式，并确定终止条件，然后将递推公式与终止条件翻译为代码。拆分问题的关键是：只关注当前层次的拆分，将拆分后的问题假设为已解决的问题。

### 如何避免递归堆栈溢出问题？

每调用一个函数时，都会将临时变量封装为栈帧压入栈中，当函数执行完毕后，再出栈。因此当递归层次很深时，一直压入栈，会有堆栈溢出的风险。为了避免堆栈溢出，有两种解决方案：

- 限制递归层次

```python
def downstair(n):
	if n>1000:
		raise Exception
    if n==1:
        return 1
    if n==2:
        return 2
    return downstair(n-1)+downstair(n-2)
```

- 通过循环手动模拟入栈出栈(倒着算)将递归转换为非递归

```python
def downstair(n):
    if n==1:
        return 1
    if n==2:
        return 2
	pre=1
    prepre=2
    result=0
    for _ in range(3,n+1):
        result=pre+prepre
        pre,prepre=prepre,result
    return result
```

### 如何避免递归中重复计算问题？

递归运算中会有很多重复计算。

![递归重复计算]()

为了避免重复计算，可以通过一个散列表来存储已经求解过得数据。

```python
HAS_RESOLERD=dict()
def downstair(n):
    if n==1:
        return 1
    if n==2:
        return 2
    if n in HAS_RESOLERD:
        return HAS_RESOLERD.get(n)
    result = downstair(n-1)+downstair(n-2)
    HAS_RESOLERD[n]=result
    return result
```

## 排序

### 如何分析一个排序算法

分析一个排序算法通常从三方面入手：

- 执行效率
  - 时间复杂度：最好、最坏、平均时间复杂度。
  - 要考虑计算时间复杂度时的系数、低阶和常数项。
  - 元素比较与交换次数。
- 内存消耗：通过空间复杂度来衡量内存消耗。
- 排序算法的稳定性：两个相同元素，排序后是否保持原次序。

### 冒泡排序

冒泡排序只会比较相邻的两个数据，如果不符合大小关系要求，则进行交换，完成一次冒泡后，则至少会确定一个元素的位置。

![冒泡排序]()

```python
def bubble_sort(elements):
    # 外层循环用于控制循环次数
    for i in range(len(elements)):
		# flag用于有序时提前退出，当该轮没有发生交换，则有序
        flag = False
        # 内层循环用于交换
        for j in range(len(elements) - i - 1):
            if elements[j] > elements[j + 1]:
                elements[j], elements[j + 1] = elements[j + 1], elements[j]
                flag = True
        if flag is False:
            break
    return elements

def test_bubble_sort():
    assert bubble_sort([]) == []
    assert bubble_sort([1]) == [1]
    assert bubble_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]
    assert bubble_sort([2, 1, 5, 3, 6, 4]) == [1, 2, 3, 4, 5, 6]
    assert bubble_sort([6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6]

if __name__ == '__main__':
    test_bubble_sort()
```

算法分析：

- 时间复杂度：最好时间复杂度为$O(1)$，最坏时间复杂度为$O(n^2)$，平均时间复杂度计算时需要引入**有序度**和**无序度**。
  - **有序度**：数组中具备顺序关系的元素对个数。`1,2,3`的有序度为`3`，有序对为`1,2、1,3、2,3`。
  - **无序度**：数组中具备无序关系的元素对个数。`3,2,1`的无序度为`3`，无序对为`3,2、3,1、2,1`。交换次数等于无序度。
  - **满有序度**：数组完全有序，其值为$n*(n-1)/2$。
  - 平均情况下的交换次数为$(n\*(n-1)/2+0)/2=n\*(n-1)/4$，因此平均时间复杂度为$O(n^2)$。
- 空间复杂度：冒泡排序是原地排序，其空间复杂度为$O(1)$。
- 稳定性：冒泡排序中只有交换才会改变元素顺序，只有当相邻元素不满足大小要求时，才会交换，因此冒泡排序是稳定排序。

### 插入排序

插入排序中，将数组分为两部分：已排序区和未排序区，每次从未排序区中去一个元素，然后在已排序区寻找插入点，插入数据。

![插入排序]()



```python
def insert_sort(elements):
    if len(elements) <= 1:
        return elements

    for i in range(1, len(elements)):
        value = elements[i]
        for j in range(i - 1, -2, -1):
            if elements[j] > value:
                elements[j + 1] = elements[j]
            else:
                break
        elements[j + 1] = value
    return elements

def test_bubble_sort():
    assert insert_sort([]) == []
    assert insert_sort([1]) == [1]
    assert insert_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]
    assert insert_sort([2, 1, 5, 3, 6, 4]) == [1, 2, 3, 4, 5, 6]
    assert insert_sort([6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6]

if __name__ == '__main__':
    test_bubble_sort()
```

算法分析：

- 时间复杂度：最好时间复杂度为$O(n)$，最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(n^2)$。
- 空间复杂度：插入排序是原地排序，其空间复杂度为$O(1)$。
- 稳定性：插入排序从后往前找插入点，因此其排序是稳定的。

### 选择排序

选择排序也分已经排序和未排序区，每次从未排序区中选取最大或最小的元素，插入已排序区。

![选择排序]()

```python
def select_sort(elements):
    if len(elements) <= 1:
        return elements

    for i in range(len(elements) - 1):
        index = i
        min_element = elements[i]
        for j in range(i, len(elements) - 1):
            if min_element > elements[j + 1]:
                min_element = elements[j + 1]
                index = j + 1
        elements[i], elements[index] = min_element, elements[i]
    return elements

def test_bubble_sort():
    assert select_sort([]) == []
    assert select_sort([1]) == [1]
    assert select_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]
    assert select_sort([2, 1, 5, 3, 6, 4]) == [1, 2, 3, 4, 5, 6]
    assert select_sort([6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6]

if __name__ == '__main__':
    test_bubble_sort()
```

算法分析：

- 时间复杂度：最好时间复杂度为$O(n)$，最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(n^2)$。
- 空间复杂度：插入排序是原地排序，其空间复杂度为$O(1)$。
- 稳定性：插入排序从后往前找插入点，因此其排序是稳定的。

### 归并排序

### 快速排序

### 计数排序

### 基数排序

### 桶排序

## 查找
