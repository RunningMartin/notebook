# 数据结构与算法学习笔记—线性表

## 数组

数组是一种线性表数据结构，采用一组连续的内存空间，来存储一组具有相同类型的数据。由于数组具备线性表与采用连续内存空间存储的特性，因此，通过下标访问数组元素时，时间复杂度为$O(1)$，数组中元素地址公式为：

- 一维数组：$arr[i]\_address=base\_address+i*size\_of\_element$
- 二维数据`arr[m][n]`：$arr[i][j]\_address=base\_address+(i*n+j)*size\_of\_element$
  在数组中，通过元素值寻找元素需要遍历整个数组，平均时间复杂度为$O(N)$；插入、删除元素需要去移动元素来空出位置或挤占空位，平均时间复杂度也为$O(N)$。在特殊情况下，可以对插入、删除操作进行优化，减少频繁迁移元素带来的损耗：
- 插入：如果插入后不要求有序，则可以直接将第`K`位的元素，插入数组尾部，再将新元素插入第`K`位，时间复杂度为$O(1)$。
- 删除：删除时，只标记元素被删除，当数组空间没有剩余空间，删除已被标记的元素，避免每次都去迁移元素(标记清除垃圾回收算法)。
  使用数组时，要警惕数组的访问越界问题(Java、Python等语言会自己检查)。C语言中，任何非访问受限的内存空间都可自由访问，因此数组越界时，会出现很多莫名其妙的问题。

```c
#include<stdio.h>
int main(){
   int i=0;
   int arr[3]={0};
   for(;i<=3;i++){
     arr[i]=0;
     printf("hello");
   }
   return 0;
}
```

在编译时如果采用`gcc -fstack-protector-all`，打开堆栈保护，不会出现死循环；如果采用`-fno-stack-protector`关闭堆栈保护，会出现死循环，因为`a[3]=0`等价于`i=0`。函数体的局部变量存放于栈，且栈是向下增长的(栈中元素依次为：`a、arr[2]、arr[1]、arr[0]`)，当使用64位操作系统时，编译器默认8字节对齐(1个int占2个字节)，因此`arr[2]`和`a`元素紧挨，如果`arr`元素个数不是$4*i-1$，则不会出现死循环。

```
#include<stdio.h>
int test_not_overflow(){
   //test not overflow when arr have four elements
   printf("test not overflow\n");
   int i=0;
   printf("i:0X%p\n",&i);
   int arr[4]={0};
   for(;i<=4;i++){
     printf("arr[%d]:0X%p\n",i,&arr[i]);
   }
   int b;
   printf("b:0X%p\n",&b);
   return 0;
}
int test_overflow(){
   //test overfolw when arr have three elements
   printf("test overflow\n");
   int i=0;
   printf("i:0X%p\n",&i);
   int arr[3]={0};
   for(;i<=3;i++){
     printf("arr[%d]:0X%p\n",i,&arr[i]);
   }
   int b;
   printf("b:0X%p\n",&b);
   return 0;
}
int main(){
   test_overflow();
   test_not_overflow();
}
```

堆栈保护参考链接：[GCC 中的编译器堆栈保护技术](https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html)

为什么大多数编程语言数组下标从0开始？数组的内存模型中，下标确切含义是偏移，当下标为0，代表起始地址，因此第`i`个元素的内存地址为:$arr[i]\_address=base\_address+i*size\_of\_element$；如果下标从1开始，则第`i`个元素的内存地址为：$arr[i]\_address=base\_address+(i-1)*size\_of\_element$，每次计算都需要多一次减法运算。

总结：数组插入删除元素的时间复杂度为$O(N)$，通过下标随机访问的时间复杂度为$O(1)$，按值访问的时间复杂度为$O(N)$。数组由于采用连续存储内存空间存储，因此可以借助CPU的缓存机制，预读取数组中的数据访问效率高。若数组过大，系统没有足够的连续内存空间，则会出现内存不足；数组过小，频繁数组扩容，则额外时间损耗过大。

## 链表

链表是一种线性表数据结构，链表将数据存储在零散内存块中，通过指针将数据串联起来。内存块被称作为节点，节点中拥有指针指向其前驱或后继。常用的链表有三种：

- 单链表：随机访问元素的平均时间复杂度为$O(N)$，指定元素后插入、删除元素的平均时间复杂度为$O(1)$，其他情况下插入、删除元素的平均时间复杂度为$O(N)$（需要从头查找元素的前驱）。
- 循环链表：循环列表是特殊的单链表，只是将链尾指向链头。
- 双链表：拥有两个指针，一个指向前驱`prev`，一个指向后继`next`，因此在指定元素前后插入、删除元素的平均时间复杂度均为$O(1)$。在有序链表中，双向链表查询效率比单链表的查询效率高，可以通过与上次查找的位置值相比较，决定向前或向后查找，平均时间复杂度为$O(N/2)$(空间换时间策略)。

如何基于链表实现LRU缓存淘汰算法？

缓存是一种提高数据读取性能的技术，但缓存大小有限，当缓存满时，通常采用先进先出策略(FIFO)、最少使用策略(LFU)、最近最少使用策略(LRU)淘汰数据。实现LRU算法时，可以维护一个有序(时间)缓存链表，越靠近链头，越是最近访问的数据。通过链表实现的LRU缓存淘汰算法平均时间复杂度为$O(N)$。可以采用散列表优化数据访问，时间复杂度为O(1)。当访问一个数据时，遍历缓存链表：

- 如果在缓存链表中，则删除该节点，插入链表头部。
- 如果没有在缓存链表中
  - 缓存未满，直接插入链表头部。
  - 缓存满，删除链尾节点，将新数据插入链表头部。



如何基于数组实现LRU缓存淘汰算法？

定义一个长度为`N`的定长数组，从`N-1`处往前分配，通过两个flag指向缓存数组的头和尾，访问数据时，遍历缓存数组：

- 如果在缓存数组中，则标记删除该数据，插入缓存数组头部。
- 如果没有在缓存数组中
  - 缓存未满且缓存数组未分配完，直接插入缓存数组头部。
  - 缓存未满但缓存数组已经分配完，删除已标记删除的数据后，插入缓存数组头部。
  - 缓存满，删除缓存数组尾部节点，将新数据插入缓存数组头部。

如何轻松编写正确的链表代码？

- 通过正确操作顺序避免指针丢失
- 删除掉的节点要释放内存空间
- 利用哨兵简化操作
- 留意边界条件处理
  - 链表为空
  - 链表只包含一个节点
  - 链表只包好两个节点
  - 链表处理头尾节点

总结：链表通过下标随机访问的时间复杂度诶$O(N)$，按值访问的时间复杂度为$O(N)$，在指定元素后插入、删除的时间复杂度为$O(1)$，其他与具体链表类型相关。链表采用零散内存空间存储数据，因此动态扩容时，没有额外时间损耗，但不能借助CPU缓存机制，提高数据访问效率。链表中每个节点至少有一个指针，因此其内存利用率不高。频繁对链表执行插入删除操作会带来频繁的内存申请与释放操作，从而导致内存碎片，如果有GC机制(如果JAVA)，还会导致频繁GC操作。

## 栈

## 队列
