# 算法思想

## 贪心算法

贪心算法适用的场景：针对一组数据，给出限制值，要求选出一定数量的数据，让期望值最大。贪心算法的核心是：每次都选取价值最高的数据。贪心算法不一定能给出最优解，这是因为当前的最优解会影响后续的选择，导致整体上不是最优解。

## 示例

**问题1**：将m个糖果分配给n个孩子(m<n)，每个糖果的大小不一，每个孩子的需求也不一样，只有当糖果的大小大于等于孩子对糖果的要求时，孩子才能得到满足。如何分配糖果才能满足更多的孩子。

**解决方案**：将孩子按需求排序，以孩子为基准，每次从孩子中选最小的，然后从糖果中选最小满足的糖果分配。

**问题2**：找零

**解决方案**：每次找满足限制条件的最大面额

**问题3**：区间覆盖，给出n个区间，每个区间的起始点和终点分别为[si,ei]，选出一部分区间，要求区间之间两两不想交。可以用于任务调度、教师排课。

**解决方案**：获取smin和emax，将问题转换为，选择几个不相交的区间，从左到右将[smin,emax]覆盖上。将n个区间先按起始点排序，再按终点排序，然后选择符合条件的长度最小的区间。

**问题4，霍夫曼编码**：根据字符出现的频率为字符编码，字符出现频率越高的，编码长度越短，并且要求不能出现某个编码是另一个编码的前缀。编码的压缩率在20%~90%之间。

**解决方案**：将字符按出现频率排序后存入优先级队列，先取两个频率最小的字符，作为一个二叉树的两个节点，其根节点的权重为二者之和，根节点入队。直到整个队列为空，树的左为0，右为1，从根节点到叶子节点的路径则为霍夫曼编码。

**问题5:**：一个非负整数a，从中移除k个数字，让剩下的数字值最小。

**解决方案**：从左到右，选取最大的数移除。

**问题6**：n个人等待被服务，但窗口只有一个，每个人需要被服务的时间长度不一，如何让n个人等待的时间最短。

**解决方案**：每次服务等待时间最小的。

## 分治算法

分治算法的核心是将问题拆分为n个规模小，且结构和原问题相似的子问题，递归解决这些子问题，然后合并结果后，就能得到原问题的解。

### 示例

**问题1**：如何求出一组数据的逆序对个数。

**解决方案**：

- 通过遍历每个数字，和后面的数字相对比大小，时间复杂度为$O(n^2)$。
- 将数组A分为两部分A1，A2，分别计算器逆序度为K1，K2，然后计算A1，A2合并之后的逆序度K3，数组A的逆序度为K1+K2+K3。整个逆序度的计算需要借用归并算法的归并函数，在归并函数中计算每个子问题的逆序度。分治算法的子问题合并代价不能太大，否则不能达到降低时间复杂度的效果。

**问题2**：二维平面上有n个点，如何快速计算出两个距离最近的点对？

**问题3**：有两个n\*n的矩阵A，B，如何快速求解两个矩阵的乘积C=A\*B？

## 回溯算法

回溯算法类似枚举搜索，为了避免重复或遗漏，在每个岔路口随机选一个，直到走不通未知，然后返回上一个岔路口，选择另一个岔路继续。回溯算法最经典的应用就是八皇后问题。

## 动态规划

**问题1**：1-0背包问题

- 采用回溯法计算

```python
def backtracking_package(goods, limit_weight):
    """
    采用回溯法解决0-1背包问题
    :param goods:商品的重量信息
    :param limit_weight:背包能承受的最大重量
    :return:
    """
    numbers = len(goods)
    max_weight = 0
    best_queue = []
    queue = []
    computer = 0

    def decision(i, current_weight):
        """
        决策第i个商品是否装入背包
        :param i:
        :param current_weight:决策前的重量
        :return:
        """
        nonlocal max_weight
        nonlocal limit_weight
        nonlocal numbers
        nonlocal best_queue
        nonlocal queue
        nonlocal computer
        # 判断当前重量是否满足限制
        if current_weight == limit_weight or i == numbers:
            if current_weight > max_weight:
                max_weight = current_weight
                best_queue = queue.copy()
            computer += 1
            return

        # 不将该商品装入背包
        decision(i + 1, current_weight)

        # 如果该商品装入背包满足条件，装入背包
        if current_weight + goods[i] <= limit_weight:
            queue.append(i)
            decision(i + 1, current_weight + goods[i])

        # 返回上一个节点，尝试下一个岔路
        if len(queue) != 0:
            queue.pop(-1)

    decision(0, 0)
    print('backtracking_package computer:{}'.format(computer))
    return max_weight, best_queue

def test_backtracking_package():
    weights = [5]
    assert backtracking_package(weights, 6) == (5, [0])

    weights = [1, 2, 4]
    assert backtracking_package(weights, 6) == (6, [1, 2])

    weights = [2, 2, 4, 6, 3]
    assert backtracking_package(weights, 9) == (9, [3, 4])

    weights = [7, 8, 9]
    assert backtracking_package(weights, 5) == (0, [])
```

- 回溯法去重

```python
def deduplicate_backtracking_package(goods, limit_weight):
    """
    采用回溯法解决0-1背包问题,通过剪枝去重，避免重复计算
    :param goods:商品的重量信息
    :param limit_weight:背包能承受的最大重量
    :return:
    """
    numbers = len(goods)
    max_weight = 0
    best_queue = []
    queue = []
    monitor = [[False for _ in range(limit_weight + 1)] for _ in range(numbers)]
    computer = 0

    def decision(i, current_weight):
        """
        决策第i个商品是否装入背包
        :param i:
        :param current_weight:决策前的重量
        :return:
        """
        nonlocal max_weight
        nonlocal limit_weight
        nonlocal numbers
        nonlocal best_queue
        nonlocal queue
        nonlocal monitor
        nonlocal computer

        # 判断当前重量是否满足限制
        if current_weight == limit_weight or i == numbers:
            if current_weight > max_weight:
                max_weight = current_weight
                best_queue = queue.copy()
            computer += 1
            return

        # 去重
        if monitor[i][current_weight]:
            return

        monitor[i][current_weight] = True
        # 不将该商品装入背包
        decision(i + 1, current_weight)

        # 如果该商品装入背包满足条件，装入背包
        if current_weight + goods[i] <= limit_weight:
            queue.append(i)
            decision(i + 1, current_weight + goods[i])

        # 返回上一个节点，尝试下一个岔路
        if len(queue) != 0:
            queue.pop(-1)

    decision(0, 0)
    print('deduplicate_backtracking_package computer:{}'.format(computer))

    return max_weight, best_queue

def test_deduplicate_backtracking_package():
    weights = [5]
    assert deduplicate_backtracking_package(weights, 6) == (5, [0])

    weights = [1, 2, 4]
    assert deduplicate_backtracking_package(weights, 6) == (6, [1, 2])

    weights = [2, 2, 4, 6, 3]
    assert deduplicate_backtracking_package(weights, 9) == (9, [3, 4])

    weights = [7, 8, 9]
    assert deduplicate_backtracking_package(weights, 5) == (0, [])
```

- 采用动态规划：动态规划用于求最优解问题。动态规划采用将整个过程分为n个阶段，每个阶段只决策一个物品是否放入背包，决策完之后，背包中的物品重量会有很多种状态对应递归树中的节点，将每一层重复的状态合并，保障每层不同的状态个数不超过包的承重范围，避免每次的状态个数指数级增长，因此时间复杂度为$O(n\*w)$，n为商品个数，w为包的承重范围。通过表来存储不同的状态，来避免重复。以空间换时间。

```python
def dynamic_planning(goods, limit_weight):
    """
    采用动态规划解决0-1背包问题
    :param goods:商品的重量信息
    :param limit_weight:背包能承受的最大重量
    :return:
    """
    numbers = len(goods)
    # 多创建一行作为哨兵，避免单独处理第0行
    status = [[False for _ in range(limit_weight + 1)] for _ in range(numbers)]
    queues = [[[] for _ in range(limit_weight + 1)] for _ in range(numbers)]

    # 单独处理第0行数据
    status[0][0] = True
    if goods[0] < limit_weight:
        status[0][goods[0]] = True
        queues[0][goods[0]].append(0)

    # 整理状态
    for i in range(1, numbers):
        # 将第i个商品不放入背包
        for j in range(limit_weight + 1):
            if status[i - 1][j] is True:
                status[i][j] = True

        # 将第i个商品放入被背包
        for j in range(limit_weight - goods[i - 1]):
            if status[i - 1][j] is True and (j + goods[i]) <= limit_weight:
                status[i][j + goods[i]] = True
                queues[i][j + goods[i]] = queues[i - 1][j] + [i]

    max_weight = 0
    best_index = 0
    # 查找最佳结果
    for i in range(limit_weight, -1, -1):
        if status[numbers - 1][i] is True:
            max_weight = i
            best_index = i
            break
    best_queue = queues[numbers - 1][best_index]
    return max_weight, best_queue


def test_dynamic_planning():
    weights = [5]
    assert dynamic_planning(weights, 6) == (5, [0])

    weights = [1, 2, 4]
    assert dynamic_planning(weights, 6) == (6, [1, 2])

    weights = [2, 2, 4, 6, 3]
    assert dynamic_planning(weights, 9) == (9, [3, 4])

    weights = [7, 8, 9]
    assert dynamic_planning(weights, 5) == (0, [])


if __name__ == '__main__':
    test_dynamic_planning()
```
