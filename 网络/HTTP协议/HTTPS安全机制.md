# HTTPS安全机制

HTTP协议具备两个致命的缺陷：采用明文传输和不安全。因此任何人都可以在链路中截获、修改甚至伪造请求、响应报文，这对于如网购、网银这类需要高度安全的应用来说，非常致命。

针对这类安全性要求极高的应用，基于HTTP的HTTPS协议诞生了，简单来说，HTTPS协议就是在HTTP协议的基础上添加了安全机制。

## 0X00 安全通信具备什么样的特性？

通常认为通信如果具备如下四个特性，则为安全通信：

- 机密性：数据只能由“可信”的人访问，对于其他人来说是不可见的。
- 完整性：数据在传输过程中不能被篡改。
- 身份验证：能确认对方的身份。
- 不可否认：对方不能否认已经发生过的行为。

## 0X01 HTTPS协议如何做到安全通信？

HTTPS协议只在HTTP协议的基础上做了三点修改：

- 协议名更换为`HTTPS`。
- 通信端口由`80`跟换为`443`。
- 下层传输协议由`TCP/IP`变更为`SSL/TLS`协议。

![HTTPS协议栈]()

## 0X02 SSL/TLS协议是什么？

SSL(Security Sockets Layer)即安全套接字层，工作于OSI模型第5层(会话层)，后面被IETF(互联网工程组)更名为TLS(Transport Layer Security)。现在运用最为广泛的是TLS 1.2。

浏览器和服务器使用TLS建立连接时需要选择一组恰当的加密算法来实现安全通信，这样的算法组合被称之为密码套件：`ECDHE-RSA-AES256-GCM-SHA384`，握手时采用`ECDHE`算法进行秘钥交换，用RSA签名和身份认证，握手后采用AES对称加密算法，秘钥长度为256位，分组模式为GCM，摘要算法SHA384用于消息认证和产生随机数。

通常很多软件都采用OpenSSL来实现TLS功能，其密码套件格式为`TLS_ECDHE-RSA-WITH_AES256-GCM-SHA384`。添加TLS作为前缀，并且采用WITH分开握手和通信算法。

## 0X03 TLS如何实现安全通信？

实现机密性最常见的手段是加密：通过某种手段将消息转换为乱码的密文，只有掌握密钥的人，才能将密文转换为明文。

加密算法中根据密钥的使用方式可以分为：

- 对称加密
- 非对称加密

### 对称加密

对称加密中用于加密和解密的密钥是相同的，因此确保机密性的核心是如何确保密钥的安全。常见的对称加密算法有`AES`和`ChaCha20`。

对称算法中还有一个分组模式的概念，它可以让算法用固定长度的密钥加密任意长度的密文，常见的有`GCM`、`CCM`算法。

`AES128-GCM`：密钥长度为128位的AES算法，采用的分组模式为GCM。

对称加密中的难题是：如何确保密钥被安全传递给对方。

### 非对称加密

非对称加密中有两个概念：公钥和私钥，这两个密钥是不同的，且成对存在。非对称加密具备单向性：采用公钥加密后的只能由私钥解密，反之也成立，常见的非对称加密算法有DH、RSA、ECC等。非对称加密可以解决对称加密中密钥交换问题，服务器只需要保存私钥即可。`ECC`算法中`ECDHE`自算法用于密钥交换，`ECDSA`用于数字签名，相比RSA，ECC在安全强度和性能上都有明显优势，`160`ECC位相当于`1024`为的RSA，`224`位相当于`2048`位的RSA，由于密钥短，其相应的计算量，消耗的内存和带宽也少了，性能机密性能也上升了。

### 混合加密

非对称加密由于需要复杂的数学运算，因此通信速度十分低，通常情况下只有在建立连接时用于交换对称加密的密钥，建立好连接后，只用对称加密，加密数据。



加密算法只能实现机密性，但是不能做到完整性、身份验证和不可否认。

### 完整性

如果不能确保数据的完整性，黑客可以通过收集足够多的密文，将修改、重组后的数据发送给服务器，通过服务器的响应来破解明文。

TLS中采用摘要算法来为数据生成一个指纹，然后将指纹与数据一起采用对称加密后传输给对方，对方解密后，通过相同的摘要算法计算数据的指纹，如果和传递过来的指纹相同，则数据没有发生修改。

摘要算法也叫哈希函数，能为任意长度的数据生成一个固定长度且唯一的指纹(摘要字符串)，且摘要算法是单向的，不能通过摘要字符串来反推出结果。TLS中采用的是SHA-2。

### 身份验证和不可否认

如果不能验证对方的身份，黑客也可以利用伪装成目标来窃取信息。

TLS中采用数字签名技术来实现身份验证和不可否认。先采用摘要算法为数据生成摘要，然后用私钥对摘要+数据进行加密，对端收到后，计算数据的摘要和用公钥解密后的摘要是否相同，来识别是否是目标用户。

### 数字证书与CA

身份验证中采用私钥机密，公钥解密来验证对方，但是这里面也存在一个公钥信任问题。如何保证这个公钥就是目标的呢？这时引入了CA(Certificate Authority)证书验证机构。CA利用自身的可信度为它签名的公钥背书，对公钥签名时，其需要将公钥，持有者，序列化，用途、有效期等信息打包后，生成一个数字证书。证书分三等DV、OV、EV，其中DV可信度最低。

CA通过信任链解决证明自身的有效性问题：低级CA找高级CA签名。信任链的背后是Root CA，只能通过自签名证书(根证书)来证明自己。各大CA的根证书会直接内置到操作系统或浏览器中，当浏览器收到服务器发送的证书，可以通过顺着证书链找到根证书，就能确定证书是否可信，从而确定证书里的公钥是否可信。

证书体系中也存在两个问题：

- CA失误或被欺骗，签发了错误的证书：可以通过CRL、OCSP及时废止有问题的证书。
- CA被黑，导致整个信任链中所有证书不可信：撤销CA的信任，将所有由它办法的CA证书视作不安全。

证书验证流程：

先查可信签发机构证书，如果不存在，则根据其签发机构再发可信签发机构，知道最后一层，如果最后一层没有在可信证书中，则警告用户。

## TLS1.2 连接过程

HTTPS建立好TCP连接后，不会直接发送请求报文，会进行TLS连接，在TCP连接的基础上完成安全连接后，才进行收发HTTP报文。

TLS协议由如下几部分组成：

- 记录协议：TLS收发的数据基本单位为记录，其他子协议都需要通过记录协议发出，并且多个记录可以通过一个TCP包发出。
- 警报协议：用于向对方发出警报。
- 握手协议：用于进行协商加密信息。
- 变更密码规范协议：通知对方后续数据将加密传输，之前的部分为明文数据。

由于多个记录可以通过同一个TCP包发出，因此最多经过两次消息往返即可完成握手。

![TLS 1.2通信流程]()

RSA握手流程

双向验证

## TLS1.3
- TLS1.2中的RSA算法不具备前向安全，因为私钥是固定的，一旦私钥泄露，之前的包都会被破解，ECDHE采用临时公钥，保证安全性
- 兼容：TS1.3为了更好的兼容，通过扩展协议完成向后兼容，hello会使用support_versions扩展，标记支持的supported_version。
- 强化安全：只有五种套件
  - 伪随机数从PRF升级为HKDF
  - 禁止在记录协议中压缩
  - 对称加密只保留：AES、ChaCha20
  - 分组只能用：GCM、CCM、Poly1305
  - 摘要算法只有：SHA256、SHA384
  - 密钥交换算法只有ECDHE和DHE
  - 椭圆曲线只有P-256等五种
- 提升性能：TLS1.2握手需要两个消息往返，而TLS由于密码套件简化，删除了key exchange，能在1个消息往返内完成握手。其利用扩展字段实现
  - supported_groups:支持的曲线
  - key_share:曲线对应的公钥
  - signature_algorithms:签名算法
  - 还能通过前提条件完成0 rtt握手。
