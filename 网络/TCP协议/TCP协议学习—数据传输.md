# TCP协议学习—数据传输

## 数据传输

当一端往对端发送数据包时，对端收到数据包后，会发送数据包ACK。

![](raw/数据传输.png)

## 实践

- 打开`WireShark`进行抓包，通过`telnet`访问主机。

![TCP 数据传输](raw/TCP 数据传输.png)

## 疑问

### 延迟确认机制

TCP协议中，确认机制是累积的，确认序号X表明所有X之前的数据都已经收到了。通常情况下，ACK包是和数据一同传输过来的，但是如果没有数据传输过来，只能单独发送ACK，导致消耗大量带宽，网络利用率下降。

RFC建议在收到数据后，延迟一段时间看看能不能和接收方要发给发送方的数据一同发送(头部总是包含确认序号)。

- 延迟ACK：如果按序收到两个数据包，则只对第二个包进行ACK，能减少一个ACK，节约带宽。
- 快速ACK：及时通知对方丢包，避免滑动窗口停等，提升吞吐率。

当收到乱序到达的TCP数据包，接收端只会回复确认按序收到的最后一个数据包序号。

### 重传机制

#### 重传超时计算

重传机制是为了避免数据包丢失情况下，重传数据包，确保包能准确到达对端。重传的等待时间应该是一个合理的动态值，过短，可能会出现对端已经的ACK包还在路上，造成带宽浪费，而且过多重传会造成网络拥塞；过长导致效率底低下。

通常超时时间RTO是依据RTT(数据包发出到收到ACK的时间)进行计算的，主要有三种算法：

- 经典算法。

  - 采样计算RTT。
  - 计算平滑RTT(SRTT)：$SRTT=\alpha*SRTT+(1-\alpha)*RTT$
  - $RTT=min(U,max(L,(\beta*SRTT)))$
  - $U$为RTO的上界，$L$为RTO的下界，$\alpha$为平滑因子，$\beta$为延迟变化因子。
  - 缺陷：RTT采样时，是按第一次发包后收到ACK的时间计算呢？还是按重传后收到ACK事件计算呢？这会导致RTTO过长或过短。

  ![](raw/经典算法-RTTO.jpg)

- Karn/Partridge算法。忽视重传，不把重传的RTT做采样，但这会导致如果网络出现波动，延迟较大，可能会重传所有的包，但这是RTO值不会得到更新。

- Jacobson/Karels算法。该算法考虑两次测量值的偏差外，还考虑变化率，变化率过大，则以变化率为自变量的函数计算，变化率小，则计算平均值。

  - 计算平滑RTT：$SRTT=SRTT+\alpha*(RTT-STRR)$
  - 计算变化值：$DevRTT=(1-\beta)*DevRTT+\beta*(|RTT-SRTT|)$
  - 计算RTO：$μ*SRTT+∂*DevRTT$
  - Linux中，α = 0.125，β = 0.25， μ = 1，∂ = 4 

确定超时时间后，就轮到如何设计定时器。

- 为每个包维护一个定时器，这样会导致定时器过多，带来巨大的内存开销和调度开销。

- 为每个链接维护一个定时器。

  - 包含数据的包发送(包含定时器)，如果没有打开定时器，则开启定时器。
  - 当所有的发出的数据都ACK了，则关闭定时器。
  - 当收到ACK时，还有数据在传输，则重启定时器。
  - 定时器超时后
    - 重传最早未被ACK的数据包
    - $RTO=min(2*RTO,RTO\_MAX)$
    - 重启定时器

  原则：没有确认的包可以超时，但是不能超时过长，且不能过早重传。

### 重传策略

- 时间驱动
  - 仅重传丢失的数据包。
    - 优点：按需重传，节约带宽
    - 缺点：速度缓慢，只能重传一个，然后等待超时，重传下一个。
  - 重传确认序号后所有的包。
    - 优点：重传速度快。
    - 缺点：浪费带宽，重传不必的数据包，可能加剧网络拥塞。
- 数据驱动
  - 快速重传：当连续收到三个确认序号相同的ACK包时，进行重传。
  - SACK(选择确认机制)：通过SACK告知详细的丢包信息

## 流量控制机制

TCP的窗口大小为16bit，其接收窗口的字节容量($2^{16}-1$)，最大可以扩展为31bit。发送端通过该窗口了解发送端的缓冲区剩余大小，调整自己的发送速率，实现端到端的流量控制。

- 发送端如何做到比较方便知道自己哪些包可以发，哪些数据包不能发？

  发送方维护一个和接收方接收窗口相同大小的发送窗口(TCP滑动窗口)，当收到ACK后，则移动到相应位置。

  ![](raw/TCP 滑动窗口.jpg)

- 如果接收端发送一个零窗口给发送端，发送端如何处理？

  发送端的发送窗口由接收端控制，当发送端收到一个零窗口时，发送端不能再发送数据，只能干等着。为了有主动探测机制，发送端采用ZWP技术，在收到零窗口后，发送ZWP包给接收端，来探测接收端的窗口大小，一共三次，间隔30~60s。

- 接收端处理能力慢，这样会导致窗口很快被填满，会出现空出几个字节窗口后，如果立即通知发送端，则会导致浪费带宽，这种情况下如何处理？

  该问题的本质是避免发送大量小包，有两个原因会导致这个问题：
  
  - 接收端一直在发送小窗口：当窗口小于某个值后，直接发送零窗口，阻止发送端发送数据，等窗口大于MSS或缓冲区有一半为空，再发送非零窗口。
  - 发送端一直在发送小包(Nagle算法)
    - 如果包长度达到MSS，则发送。
    - 如果包含有FIN，则发送。
    - 如果设置了TCP_NODELAY，则发送。
    - 设置了TCP_CORK后，若所发小数据包都被确认，则允许发送(保证最多发一个小包)
    - 如果都不满足，但已经超时(200ms)，则发送。
  - Nagle算法和延迟确认一起，当出现`write-write-read`时，会出现一个40ms延时问题(40ms是延迟确认的超时事件)

## 拥塞控制机制

- 网络拥塞的本质：
  - 独占整个网络资源，TCP只能看到对端的接收能力，而无法感知链路上的容量，如果处理能力强，导致以很大速率发包，则会导致链路拥堵，从而引发重传风暴，进一步加剧链路拥塞。
  - 链路上的转发节点
- Reno算法
  - 冗余ACK(没有带来最小的信息)
    - 接收端接收到ACK时已经发出还未ACK的包。
    - ACK没有数据。
    - ACK的SYN和FIN位为0
    - ACK的确认号等于已收到的最大ACK确认号。
    - 该ACK通知的窗口与上一个ACK通知窗口相同。
  - 慢热启动：刚接入网络时会慢慢发包
    - 初始化`cwnd=N`，表明可以传N个MSS大小的数据(N=10)。
    - 等收到一个ACK，++cwnd，呈线性上升。
    - 每过一个RTT，cwnd=cwnd*2，指数上升
    - 当cwnd>=ssthresh(门槛，65535字节)时，进入拥塞避免算法。
  - 拥塞避免
    - 每收到一个ACK，则cwnd=(cwnd+1/cwnd)*MSS个字节。
    - 每经过RTT，cwnd增加一个MSS。
    - 出现RTO超时，重传包：ssthresh=cwnd/2，重置cwnd为1，进入慢启动状态。
    - 在出现RTO超时前，收到三个冗余ACK，则表示有中间有部分包丢失，但是有ACK，则说明拥塞不严重，因此拥塞窗口不易大幅度变化，进入快速重传。
  - 快速重传
    - 调整门限ssthresh=cwnd/2；
    - 2） cwnd=ssthresh；
    - 3） 进入快速恢复阶段。
  - 快速恢复阶段：核心思想数据包守恒，即带宽不变的情况下，网络同一时刻能容纳数据包数量恒定，因此收到一个ACK，意味着有一个包被收到了，++cwnd。
    - cwnd=cwnd+3，重传冗余ACK要求的数据包。
    - 收到冗余ACK，++cwnd
    - 收到新ACK，cwnd=sshthresh，进入拥塞避免。
    - 缺点：3个冗余ACK可能丢失了多个包，快速重传只重传了一个包，其他包只能等待RTO超时，ssthresh会减半，进入慢启动状态。多个超时会导致TCP传输速率呈级数下降。因此Reno算法会重传冗余ACK要求的包，如果重传后的ACK告知所发出的数据都收到了，则只丢失了一个包，否则丢失多个，会重传窗口未被ACK的第一个包，知道所发出的包都被ACK，再退出快速恢复(SACK会携带要重传的信息)
  - 拥塞避免阶段，cwnd是线性增加，出现拥塞时采取指数递减，这是因为增加只有利于自己，减少有利于大家，实现了公平性。

- TCP发送窗口处于稳定状态
  - 接收端大窗口锯齿状：TCP接收端拥有较大窗口，每个TCP公平竞争网络带宽，在慢启动和拥塞避免之间转变。
  - 接收端小窗口直线状：接收端速度慢，发送窗口小，因此数据量小，避免拥塞，因此发送窗口处于慢慢直线增加。
  - 满载直线状态：只存在于两端直连且只要一个连接。