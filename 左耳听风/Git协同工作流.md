# Git协同工作流

Git是一款分布式版本管理工具，分布式意味着存在数据不一致，因此选择一个合适的协同工作流让工作变得高效的同时还能让代码具备更好的一致性。

## 中心式协同工作流

中心式协同工作流是将主库当做一个公共空间，大家都在上面进行修改，主要流程如下：

![中心式协同工作流]()

- 获取主干最新代码：`git pull origin master`
- 本地修改并保存到本地仓库：
  - 选择相应修改：`git add -p`
  - 提交：`git commit -m '提交备注'`
- 提交代码：`git push origin master`
- 拉取冲突：`git pull --rebase`
- 解决冲突：`git add -p|git rebase --continue`

整体提交记录变化如图：

![中心式协同工作流提交记录变化]()



中心式协同工作流只适用于小团队的情况，在大团队中会面临代码干扰严重。

## 功能分支协同工作流

中心式协同工作流的操作单位是库的主干，面对人数较多的团队，中心式带来的干扰太多，为了解决这个问题，功能分支协同工作流将干扰范围缩小。功能分支要求从主干按功能为单位切出新的分支，负责这个功能的同事在新分支上操作，等整个功能开发完成后，再合入主干。

![功能分支协同工作流]()

- 创建新功能分支：`git checkout -b new_feature`
- 以中心式协同工作流操作新的功能分支。
- 通过Pull Request的方式完成Code Review并合入master。

![功能分支协同工作流提交记录变化]()

## Git Flow协同工作流

Git Flow协同工作流主要用于应对不同的场景下对代码的要求：

- master分支：用于生产环境，主干分支的每次提交都是可以发布的。
- hotfix分支：用于修复master的bug。
- release分支：用于发布前的准备。
- developer分支：用于集成测试。
- future分支：用于开发新的功能。

![Git Flow协同工作流]()

![Git Flow协同工作流提交记录变化]()

git flow的问题：

- 日志混乱：只有分支合并时采用git merge --no-ff，其他采用非--no-ff。
- 维护多个分支，容易出问题。
- 

## GitHub Flow协同工作流

Github Flow采用开发人员各自fork一份官方库到自己的代码仓库中，然后在将自己的库拉倒本地，新建分支，再将库push到远端自己的代码库，最后向官方库发起Pull Request。CI问题提及

![GitHub Flow协同工作流]()

## GitLab Flow协同工作流



![GitLab Flow协同工作流]()

![GitLab Flow协同工作流提交记录变化]()

## 总结

协同工作流的本质是如何简化软件架构和软件开发流程，如果离开这二者去谈Git协同工作流，无疑是修建空中楼阁，哪个都不适合。

- 微服务(本质是Unix哲学：只做一件事并把它做好)或SOA架构：微服务的核心是将一个大软件拆分为若干个服务，随之代码也被拆分为若干个代码仓库，因此协同工作流很简单。每个服务的代码和迭代速度变得很快，适用一些比较轻的协同工作流，如：github flow或功能分支。
- 以DevOps为主的开发流程。DevOps的核心是CI/CD，用于自动化的集成测试和持续部署







git cherry-pick

git grep $regexp
