# MySQL

## 事务和锁

### 事务的启动方式

```mysql
start transaction with consistent snapshot;
update t set k=k+1 where id=1;
commit;
```

`begin|start transaction`只是声明一个事务，事务的实际启动方式有两种：

- 执行第一个语句时，才创建一致性视图。
- 通过`start transaction with consistent snapshot`创建一致性视图。

### 视图

`MySQL`中存在两个视图概念：

- `view`：通过`create view`语句创建的视图，它是查询语句定义的虚拟表。
- `consistent read view`(一致性读视图)：该视图在`MVCC`(多版本并发控制)中使用，用于实现`Read Commited`(读提交)和`Repeatable Read`(可重复读)。

### 一致性读

可重复读隔离级别下，事务在启动时，会创建一个基于整个库的快照。InnoDB利用行数据多个版本的特性，实现了秒级创建快照。

InnoDB中，每个事务开始时，都会向事务系统申请`transaction ID`，该`ID`是按申请顺序严格递增。每次更新行数据，都会在当前版本的基础上，生成新版本的数据，并创建回滚记录(`undo log`)，回滚记录和当前版本的数据都会记录生成该记录的事务`transaction ID`，记做`row trx_id`。因此当一个记录被多个事务连续更新后，整个流程的状态为：

![多个事务更新记录]()

每个事务快照的数据可以通过对当前的记录执行回滚操作，计算出快照中的数据。

可重复读隔离级别下，事务启动时，能看到之前已经提交的事务结果，但事务执行期间，其他的事务的更新，则是不可见的。

事务启动时，会创建一个数组用于记录当前启动了但还未提交的事务ID。数组有序排列后，取最小值和最大值+1，分别记作为低水位和高水位。通过两个水位则可以将所有的事务分隔为三部分：

![事务分隔]()

- 低于低水位：已提交的事务。
- 高于高水位：未启动事务。
- 处于高低水位之间：
  - 数组中：启动，但未提交的事务。
  - 不在数组中：启动，但已经提交了。

执行一致性读操作时，则会从当前版本开始，一直往前回滚，直到`row trx_id`处于低水位为止。

### 当前读

更新数据时，如果根据一致性读的数据进行更新，则会出现更新覆盖问题，因此更新数据操作都是先读取当前记录的值，然后在当前记录的基础上进行修改，因此更新后，立即查询，会获取到更新后的数据。如果查询语句加锁，则也会执行当前读操作。

- `select k from t where id=1 lock in share mode`：加读锁。
- `select k from t where id=1 for update`：加写锁。

遇到加锁的情况时，如果当前的记录的行锁被其他事务占用，则需要等待锁的释放。

读提交和可重复读的逻辑类似，只是读提交隔离级别下，每个语句执行前都会重新计算一个新的视图。读提交隔离级别中，一致性快照将不再起作用。

### 为什么表结构不支持可重复读？

因为表结构没有对应的行数据，也没有`row trx_id`，只能执行当前读的逻辑。

### 思考问题

- 如何删除表的前`10000`行？

  直接执行`delete from T limit 10000`，单个语句占用时间长，锁的时间也比较长，并且大事务还会导致主从延迟。如果采用`20`个连接同时执行`delete from T limit 500`，则会人为造成锁冲突。综上，推荐在一个连接中循环执行`20`次`delete from T limit 500`或先获取前`10000`个ID，然后用`20`个连接各删除指定的`500`条记录，避免锁带来的问题。

- 事务中如果出现更新失败，如何处理？

  ![第9节更新失败问题]()

  由于普通的`select`语句是一致性读，而`update`是当前读，因此则会出现当前事务执行`select`后，事务B执行`update`后，事务A再执行`select`，前后两次`select`操作都的数据都相同。这种情况可能会出现在乐观锁下，使用`update ... set ... where id=xxx and version=xxx`，如果`version`被其他事务抢先更新，则自己的事务会更新失败(没有匹配记录，`affect_row=0`)，但事务内再次`select`的还是旧值。针对这种问题，乐观锁事务不管成功还是失败，都结束当前事务。通过判断`affect_row`，确定是否要重新创建事务。

