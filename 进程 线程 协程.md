# 进程、线程、协程

## 概念

- 进程：程序的一次执行。操作系统以进程为单位为其分配系统资源。CPU在同一时刻只能运行一个进程，每次运行时，都需要去加载进程上下文。进程最为系统资源的拥有者，其创建、切换、撤销时代价很大，因此出现线程这个概念。
- 线程：线程是进程中的一个实体，其只拥有最基本的系统资源，因此切换上下文时，代价低，如果同一个进程中有多个线程，它们共享进程拥有的资源。现代操作系统将线程作为基本调度单位。在使用多线程时，需要通过锁机制来防止因竞争产生不可用预料的结果(如同时往同一个文件中写入信息)。
- Python中的多线程：Python为了保证虚拟机内部共享资源访问的互斥性(防止因CPU的多线程调度机制导致的不可预料结果：如两个线程同时释放一个资源)，添加了**GIL**锁，每个线程运行前必须获取**GIL**锁才能被虚拟机运行，虚拟机运行一定字节码后，会主动退出，释放**GIL**锁(如果调用C语言扩展，可以绕过该机制)。
- 协程：协程的调度是由用户自行切换，因此没有了上下文切换消耗，也避免了线程安全问题。

- 并发：CPU在同一时间段内运行多个进程，但在同一时刻中只能运行一个进程。
- 并行：多个CPU同时处理多个任务。

协程库：gevent

## 多线程库:threading

### 函数

- active_count()：返回存活的Thread对象。
- current_thread()：返回当前运行的Thread对象。
- enumerate()：以列表形式返回当前存活的Thread对象。
- main_thread()：返回主线程，即启动解释器时创建的线程。
- settrace(func)：为所有从threading中创建的线程设置追踪函数，会在调用run()之前，传递给`sys.settrace`，具体描述请看`sys`库关于`settrace`的文档描述。
- setprofile(func)：为所有从threading中创建的线程设置性能测试函数，会在调用run()之前，传递给`sys.setprofile`，具体描述请看`sys`库关于`setprofile`的文档。
- stack_size([size])：返回创建线程用的堆栈大小，如果指定size，则设置为新建线程的堆栈大小，为32KB的整数倍。
- RLock：返回一个递归锁。

### Thread

创建一个线程有两种方法：

- 使用任务初始化一个`Thread`对象：`Thread(target=func,args=元组形式参数信息)`
- 继承`Thread`，重写`__init__`和`run`方法，`run`方法中写入线程的任务。

初始化线程时，有个`dameon`参数用于设置守护线程，通常情况下，主线程创建的子线程如果没有结束，则逐渐从也不能结束，但如果主线程为守护线程，则可以直接退出。

常用方法：

- start()：启动线程。
- run()：线程的任务
- join([timeout])：阻塞当前线程，直到目标线程结束，若指定了timeout，则会在这段时间内判断线程是否存活，超时，返回None，因此要结合is_alive()共同判断。
- is_alive()：判断线程是否存活。
- ident：线程ID，如果还未启动，则为None；启动状态下返回非零整数。

### 锁

多线程协同时，如果同时访问一个资源，可能会带来难以预料的问题，因此`threading`提供锁来保证任意时刻访问该资源的线程只有一个，锁有两类：

- 互斥锁`Lock`：锁没有释放前，拥有锁的线程不能多次获取。
- 递归锁`RLock`：锁没有释放前，拥有锁的线程能多次获取，内部有计数器统计被获取了多少次，因此获取与释放次数必须相同，直到为0，才能被其他线程获取。
- 使用锁时，要防止多个函数使用同一个锁又互相调用引发死锁。

锁对象的常用方法：

- acquire(blocking=True,timeout=-1)：获取锁，如果blocking为True，则会阻塞，直到获取该锁，timeout会现在阻塞时长。如果blocking为false，则获取到锁，返回True，没有获取，返回False。
- release()：释放锁

## 多进程:mulitprocessing

<https://blog.51cto.com/11026142/1867519>

